<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guild Master</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <script src="js/data/traitData.js"></script>
    <script src="js/data/questData.js"></script>
    <script src="js/models/Adventurer.js"></script>
    <script src="js/systems/Resolution.js"></script>
    <script src="js/models/VisualTraits.js"></script>
    <script src="js/models/VisualTraits.js"></script>
    <script src="js/systems/Inspector.js"></script>
    <script src="js/systems/Persistence.js"></script>
    <script src="js/systems/Economy.js"></script>
    <script src="js/systems/Input.js"></script>
</head>

<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-layer"></div>
        <div id="debug-console"
            style="position: absolute; top: 0; left: 0; color: lime; background: rgba(0,0,0,0.8); font-family: monospace; padding: 10px; pointer-events: none; width: 100%; height: 50%; overflow: hidden; display: none;">
        </div>
    </div>
    <!-- Debug Console Script -->
    <script>
        const debugConsole = document.getElementById('debug-console');
        debugConsole.style.display = 'block'; // Make visible immediately
        debugConsole.innerHTML = "<div>Status: Debug Console Loaded...</div>";

        function logToScreen(msg, color = 'white') {
            debugConsole.innerHTML += `<div style="color: ${color};">${msg}</div>`;
        }

        // Global Error Handler
        window.onerror = function (msg, url, line, col, error) {
            const fileName = url ? url.split('/').pop() : 'unknown';
            logToScreen(`ERROR: ${msg} <br> File: ${fileName} : Line ${line}`, 'red');
            return false;
        };

        // Async Promise Error Handler
        window.addEventListener('unhandledrejection', function (event) {
            logToScreen(`ASYNC ERROR: ${event.reason}`, 'orange');
        });

        // Console Log Override
        const originalLog = console.log;
        console.log = function (...args) {
            originalLog.apply(console, args);
            logToScreen(`LOG: ${args.join(' ')}`, '#00FF00');
        };

        logToScreen("Waiting for module to load...", 'yellow');

        // 1. DATA (Previously adventurerData.js)
        const ADVENTURER_DATA = {
            archetypes: {
                MARTIAL: {
                    name: "Martial",
                    classes: [
                        { id: "knight", name: "Knight-Errant", traits: ["Honorbound", "Arrogant"], stats: { str: [8, 10], int: [2, 5], dex: [4, 6] } },
                        { id: "barbarian", name: "Barbarian", traits: ["Battle-Rage", "Illiterate"], stats: { str: [9, 10], int: [1, 3], dex: [5, 7] } },
                        { id: "mercenary", name: "Mercenary", traits: ["Greedy", "Pragmatic"], stats: { str: [6, 8], int: [4, 6], dex: [5, 7] } },
                        { id: "pit_fighter", name: "Pit Fighter", traits: ["Sadist", "Showman"], stats: { str: [7, 9], int: [2, 4], dex: [7, 9] } },
                        { id: "guard", name: "Town Guard", traits: ["Lazy", "Corrupt"], stats: { str: [5, 7], int: [3, 5], dex: [4, 6] } },
                        { id: "ronin", name: "Ronin", traits: ["Wanderer", "Disciplined"], stats: { str: [7, 9], int: [4, 6], dex: [8, 10] } }
                    ]
                },
                ARCANE: {
                    name: "Arcane",
                    classes: [
                        { id: "battle_mage", name: "Battle Mage", traits: ["Pyromaniac", "Short-Tempered"], stats: { str: [4, 6], int: [8, 10], dex: [4, 6] } },
                        { id: "scholar", name: "Scholar", traits: ["Cowardly", "Curious"], stats: { str: [2, 4], int: [9, 10], dex: [3, 5] } },
                        { id: "necromancer", name: "Necromancer", traits: ["Outcast", "Creepy"], stats: { str: [3, 5], int: [8, 10], dex: [3, 5] } },
                        { id: "illusionist", name: "Illusionist", traits: ["Liar", "Kleptomaniac"], stats: { str: [3, 5], int: [7, 9], dex: [8, 10] } },
                        { id: "elementalist", name: "Elementalist", traits: ["Volatile", "Connected"], stats: { str: [4, 6], int: [7, 9], dex: [5, 7] } },
                        { id: "hedge_wizard", name: "Hedge Wizard", traits: ["Helpful", "Unlicensed"], stats: { str: [3, 5], int: [5, 7], dex: [4, 6] } }
                    ]
                },
                CUNNING: {
                    name: "Cunning",
                    classes: [
                        { id: "rogue", name: "Rogue", traits: ["Greedy", "Traitor"], stats: { str: [3, 5], int: [5, 7], dex: [8, 10] } },
                        { id: "ranger", name: "Ranger", traits: ["Loner", "Nature-Lover"], stats: { str: [5, 7], int: [4, 6], dex: [8, 10] } },
                        { id: "bard", name: "Bard", traits: ["Drunk", "Flirtatious"], stats: { str: [3, 5], int: [6, 8], dex: [7, 9] } },
                        { id: "assassin", name: "Assassin", traits: ["Cold-Blooded", "Contract_Killer"], stats: { str: [5, 7], int: [6, 8], dex: [9, 10] } },
                        { id: "treasure_hunter", name: "Treasure Hunter", traits: ["Obsessive", "Unlucky"], stats: { str: [4, 6], int: [5, 8], dex: [7, 9] } },
                        { id: "spy", name: "Spy", traits: ["Double Agent", "Paranoid"], stats: { str: [4, 6], int: [8, 10], dex: [6, 8] } }
                    ]
                },
                DIVINE: {
                    name: "Divine",
                    classes: [
                        { id: "cleric", name: "Cleric", traits: ["Zealot", "Pacifist"], stats: { str: [5, 7], int: [7, 9], dex: [3, 5] } },
                        { id: "paladin", name: "Paladin", traits: ["Lawful Stupid", "Judgemental"], stats: { str: [8, 10], int: [4, 6], dex: [4, 6] } },
                        { id: "druid", name: "Druid", traits: ["Feral", "Territorial"], stats: { str: [5, 7], int: [6, 8], dex: [6, 8] } },
                        { id: "monk", name: "Monk", traits: ["Vow of Silence", "Disciplined"], stats: { str: [7, 9], int: [6, 8], dex: [9, 10] } },
                        { id: "cultist", name: "Cultist", traits: ["Insane", "Doomed"], stats: { str: [4, 6], int: [5, 7], dex: [5, 7] } }
                    ]
                }
            }
        };

        // 2. MODEL (Imported from js/models/Adventurer.js)
        // class Adventurer removed to avoid duplicate declaration error


        // 3. GENERATOR (Previously adventurerGenerator.js)
        class AdventurerGenerator {
            static generate(day = 1) {
                const archetypeKeys = Object.keys(ADVENTURER_DATA.archetypes);
                const archetypeKey = archetypeKeys[Math.floor(Math.random() * archetypeKeys.length)];
                const archetypeData = ADVENTURER_DATA.archetypes[archetypeKey];
                const charClass = archetypeData.classes[Math.floor(Math.random() * archetypeData.classes.length)];

                const stats = {
                    str: this.randomRange(charClass.stats.str[0], charClass.stats.str[1]),
                    int: this.randomRange(charClass.stats.int[0], charClass.stats.int[1]),
                    dex: this.randomRange(charClass.stats.dex[0], charClass.stats.dex[1]),
                    vit: this.randomRange(3, 8)
                };

                const traits = [...charClass.traits];
                const equipment = { mainHand: "Basic Weapon", armor: "Basic Armor" };
                const names = ["Garrett", "Lyra", "Thorn", "Elara", "Ragnar", "Sylas"];
                const name = names[Math.floor(Math.random() * names.length)] + " the " + charClass.name;

                return new Adventurer({
                    name: name,
                    archetype: archetypeKey,
                    classId: charClass.id,
                    stats: stats,
                    traits: traits,
                    equipment: equipment
                });
            }

            static randomRange(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
        }

        // 4. RENDERER (Previously Renderer.js)
        class Renderer {
            constructor(canvas) {
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                this.assets = {};
                this.isLoaded = false;
            }

            loadAssets() {
                return new Promise((resolve) => {
                    let loaded = 0;
                    const checkDone = () => { if (++loaded >= 2) resolve(); };

                    // Start Screen Background (New Optimized Title Screen)
                    const imgStart = new Image();
                    imgStart.src = 'assets/title_screen.png';
                    imgStart.onload = () => { this.assets['bg_start'] = imgStart; checkDone(); };
                    imgStart.onerror = () => { logToScreen("Start BG Failed", 'orange'); checkDone(); };

                    // Game Screen Background (Papers Please POV Counter View)
                    const imgGame = new Image();
                    imgGame.src = 'assets/counter_view.png';
                    imgGame.onload = () => { this.assets['bg_game'] = imgGame; logToScreen("Game BG Loaded", 'lime'); checkDone(); };
                    imgGame.onerror = () => { logToScreen("Game BG Failed", 'orange'); checkDone(); };
                });
            }

            draw(gameState) {
                this.ctx.clearRect(0, 0, this.width, this.height);

                // Select Background based on Screen State
                let bgKey = gameState.screen === 'START' ? 'bg_start' : 'bg_game';
                if (this.assets[bgKey]) {
                    this.ctx.drawImage(this.assets[bgKey], 0, 0, this.width, this.height);
                } else {
                    this.ctx.fillStyle = "#3e3e3e";
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }

                if (gameState.screen === 'START') {
                    this.drawStartScreen();
                } else if (gameState.screen === 'GAME') {
                    this.drawGameScreen(gameState);
                } else if (gameState.screen === 'REPORT') {
                    this.drawMorningReport(gameState);
                }
            }

            drawMorningReport(gameState) {
                // 1. Background (Wooden Table)
                this.ctx.fillStyle = "#3d2817"; // Dark wood
                this.ctx.fillRect(0, 0, this.width, this.height);
                // Wood grain lines (simple)
                this.ctx.fillStyle = "#4a321e";
                for (let i = 0; i < this.height; i += 40) {
                    this.ctx.fillRect(0, i, this.width, 2);
                }

                // 2. The Ledger (Open Book)
                const bookW = 800;
                const bookH = 600;
                const bx = (this.width - bookW) / 2;
                const by = (this.height - bookH) / 2;

                // Cover (Leather)
                this.ctx.fillStyle = "#2a1a10";
                this.ctx.fillRect(bx - 20, by - 20, bookW + 40, bookH + 40);

                // Pages
                this.ctx.fillStyle = "#f5e6d3"; // Parchment
                this.ctx.fillRect(bx, by, bookW / 2 - 5, bookH); // Left Page
                this.ctx.fillRect(bx + bookW / 2 + 5, by, bookW / 2 - 5, bookH); // Right Page

                // Spine Shadow
                this.ctx.fillStyle = "rgba(0,0,0,0.2)";
                this.ctx.fillRect(bx + bookW / 2 - 20, by, 40, bookH);

                // 3. Text Content
                this.ctx.fillStyle = "#3e2723"; // Ink
                this.ctx.font = "bold 32px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText("Guild Daily Ledger", bx + bookW / 4, by + 60);
                this.ctx.fillText("Day " + gameState.day, bx + bookW * 0.75, by + 60);

                // Separator Lines
                this.ctx.fillRect(bx + 40, by + 80, bookW / 2 - 80, 2);
                this.ctx.fillRect(bx + bookW / 2 + 40, by + 80, bookW / 2 - 80, 2);

                // Entries (Render on Left Page first, then spill to Right)
                this.ctx.font = "16px 'MedievalSharp', cursive";
                this.ctx.textAlign = "left";

                let cx = bx + 40;
                let cy = by + 120;
                let pageSwap = false;

                if (gameState.pendingReports && gameState.pendingReports.length > 0) {
                    gameState.pendingReports.forEach((report, idx) => {
                        // Check for page overflow/switch
                        if (cy > by + bookH - 100 && !pageSwap) {
                            pageSwap = true;
                            cx = bx + bookW / 2 + 40;
                            cy = by + 120;
                        }

                        // Colors for stamps/marks
                        const markColor = report.result === "SUCCESS" ? "#2e7d32" : (report.result === "FAILURE" ? "#c62828" : "#ef6c00");

                        // Entry Header
                        this.ctx.fillStyle = markColor;
                        this.ctx.font = "bold 16px 'MedievalSharp', cursive";
                        const resultMark = report.result === "SUCCESS" ? "[✔]" : (report.result === "FAILURE" ? "[✖]" : "[?]");
                        this.ctx.fillText(`${resultMark} ${report.questTitle}`, cx, cy);

                        // Adventurer Name
                        this.ctx.fillStyle = "#5d4037";
                        this.ctx.font = "italic 14px 'MedievalSharp', cursive";
                        this.ctx.fillText(`   Assigned: ${report.adventurerName}`, cx, cy + 20);

                        // Outcome/Flavor
                        this.ctx.fillStyle = "#3e2723";
                        this.ctx.font = "14px 'MedievalSharp', cursive";
                        // Wrap text roughly
                        let desc = "> " + report.flavorText;
                        if (desc.length > 40) {
                            this.ctx.fillText(desc.substring(0, 40) + "...", cx, cy + 40);
                        } else {
                            this.ctx.fillText(desc, cx, cy + 40);
                        }

                        cy += 70; // Spacing per entry
                    });
                } else {
                    this.ctx.fillStyle = "#8d6e63";
                    this.ctx.fillText("No guild activity recorded.", cx, cy);
                }

                // 4. Continue Prompt (Bookmark?)
                this.ctx.fillStyle = "#8b0000";
                this.ctx.fillRect(bx + bookW - 60, by + bookH, 40, 60); // Bookmark sticking out

                this.ctx.fillStyle = "white";
                this.ctx.font = "bold 16px monospace";
                this.ctx.textAlign = "center";
                this.ctx.fillText("NEXT", bx + bookW - 40, by + bookH + 35);
                this.ctx.font = "12px monospace";
                this.ctx.fillText("(SPC)", bx + bookW - 40, by + bookH + 50);
            }

            drawStartScreen() {
                // Dim background
                this.ctx.fillStyle = "rgba(0,0,0,0.6)";
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Title
                this.ctx.fillStyle = "#FFD700";
                this.ctx.font = "bold 60px monospace";
                this.ctx.textAlign = "center";
                this.ctx.shadowColor = "black";
                this.ctx.shadowBlur = 10;
                this.ctx.fillText("GUILD MASTER", this.width / 2, this.height / 2 - 50);
                this.ctx.shadowBlur = 0;

                // Play Button
                this.ctx.fillStyle = "#8B4513";
                this.ctx.fillRect(this.width / 2 - 100, this.height / 2 + 50, 200, 60);
                this.ctx.border = "2px solid #fff";

                this.ctx.fillStyle = "#fff";
                this.ctx.font = "30px monospace";
                this.ctx.fillText("PLAY", this.width / 2, this.height / 2 + 90);

                this.ctx.font = "16px monospace";
                this.ctx.fillStyle = "#ccc";
                this.ctx.fillText("[Press SPACE or Click]", this.width / 2, this.height / 2 + 150);
            }

            drawGameScreen(gameState) {
                // Draw Quests on Board
                if (gameState.quests) {
                    this.drawQuestBoard(gameState.quests);
                }

                // Draw Adventurer
                const hero = gameState.currentAdventurer;
                if (hero) {
                    this.drawAdventurerPlaceholder(hero);
                }

                // UI: Gold & Day
                this.ctx.fillStyle = "#FFD700";
                this.ctx.font = "bold 24px monospace";
                this.ctx.textAlign = "left";
                this.ctx.fillText(`Gold: ${gameState.economy.gold}`, 20, 40);

                this.ctx.fillStyle = "white";
                this.ctx.fillText(`Day: ${gameState.day}`, 20, 70);

                // UI: End Day (Hanging Sign Top Right)
                // Draw Rope
                this.ctx.strokeStyle = "#5d4037";
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(925, 0);
                this.ctx.lineTo(925, 30);
                this.ctx.stroke();

                // Draw Sign Board
                this.ctx.fillStyle = "#4a321e"; // Wood
                this.ctx.fillRect(860, 30, 130, 50);
                this.ctx.fillStyle = "#3e2723"; // Border
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(860, 30, 130, 50);

                this.ctx.fillStyle = "#d7ccc8"; // Text
                this.ctx.font = "bold 18px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText("END DAY", 925, 62);


                // UI: Dismiss Area (Bottom Right - "The Door")
                // Instead of a button, an area to drag to? Or just a clickable "Exit" sign?
                // Let's make it a robust Stone Button/Plaque at the bottom
                const btnX = 412;
                const btnY = 620;
                const btnW = 200;
                const btnH = 60;

                // Stone Texture
                this.ctx.fillStyle = "#546e7a";
                this.ctx.fillRect(btnX, btnY, btnW, btnH);

                // Bevel
                this.ctx.fillStyle = "#78909c";
                this.ctx.fillRect(btnX, btnY, btnW, 4); // Top highlight
                this.ctx.fillStyle = "#37474f";
                this.ctx.fillRect(btnX, btnY + btnH - 4, btnW, 4); // Bottom shadow

                this.ctx.fillStyle = "#eceff1";
                this.ctx.font = "bold 22px 'MedievalSharp', cursive";
                this.ctx.fillText("DISMISS", btnX + btnW / 2, btnY + 38);


                // Draw Dragged Item (Floating on top)
                if (gameState.dragState) {
                    this.drawDraggedQuest(gameState.dragState);
                }

                // Draw Report Overlay
                if (gameState.report) {
                    this.drawReportCard(gameState.report);
                }

                // Draw Inspection Overlay (if active)
                if (gameState.inspectionData) {
                    this.drawInspectionWindow(gameState.inspectionData);
                }

                // Draw STAMP Animation
                if (gameState.stamp) {
                    this.drawStamp(gameState.stamp);
                }
            }

            drawStamp(stamp) {
                // Animate value
                if (stamp.val < 1) stamp.val += 0.08;
                const scale = 2.5 - Math.min(1.0, stamp.val) * 1.5; // 2.5 -> 1.0 big slam
                const alpha = Math.min(1, stamp.val * 3);

                this.ctx.save();
                this.ctx.translate(this.width / 2, this.height / 2);
                this.ctx.scale(scale, scale);
                this.ctx.rotate((Math.random() - 0.5) * 0.2); // Organic rotation

                this.ctx.globalAlpha = alpha;

                // 1. WAX BLOB (Organic Shape)
                const color = stamp.type === 'ASSIGNED' ? "#8b0000" : "#2f2f2f";
                this.ctx.fillStyle = color;

                this.ctx.beginPath();
                // Draw a wobbly circle
                for (let i = 0; i <= Math.PI * 2; i += 0.2) {
                    let r = 100 + Math.random() * 10 - 5;
                    this.ctx.lineTo(Math.cos(i) * r, Math.sin(i) * r);
                }
                this.ctx.closePath();
                this.ctx.fill();

                // Inner rim hint
                this.ctx.strokeStyle = "rgba(0,0,0,0.2)";
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                // 2. EMBOSSED SIGIL (Sword/Shield or X)
                this.ctx.fillStyle = "rgba(0,0,0,0.3)"; // Embossed shadow look

                if (stamp.type === 'ASSIGNED') {
                    // Draw Shield Crest
                    this.ctx.beginPath();
                    this.ctx.moveTo(-40, -50);
                    this.ctx.lineTo(40, -50);
                    this.ctx.lineTo(40, 10);
                    this.ctx.quadraticCurveTo(0, 60, -40, 10);
                    this.ctx.closePath();
                    this.ctx.fill();

                    // Sword line
                    this.ctx.fillStyle = "rgba(0,0,0,0.4)";
                    this.ctx.fillRect(-5, -70, 10, 120);
                    this.ctx.fillRect(-20, -40, 40, 10); // Hilt
                } else {
                    // Draw "X" or "Dismiss Hand"
                    this.ctx.beginPath();
                    this.ctx.moveTo(-50, -50);
                    this.ctx.lineTo(50, 50);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.moveTo(50, -50);
                    this.ctx.lineTo(-50, 50);
                    this.ctx.stroke();
                }

                // 3. TEXT on the Rim (Small, Medieval)
                // this.ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
                // this.ctx.font = "bold 16px MedievalSharp";
                // this.ctx.textAlign = "center";
                // this.ctx.fillText(stamp.type, 0, 80); 

                this.ctx.restore();
            }

            drawInspectionWindow(data) {
                const x = 50;
                const y = 200;
                const w = 300;
                const h = 400;

                // Panel
                this.ctx.fillStyle = "rgba(0, 20, 40, 0.9)";
                this.ctx.fillRect(x, y, w, h);
                this.ctx.strokeStyle = "cyan";
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, w, h);

                // Header
                this.ctx.fillStyle = "cyan";
                this.ctx.font = "bold 18px monospace";
                this.ctx.textAlign = "left";
                this.ctx.fillText("INSPECTION SCANNER", x + 15, y + 30);
                this.ctx.fillRect(x + 15, y + 40, w - 30, 2);

                // Name
                this.ctx.fillStyle = "white";
                this.ctx.font = "bold 16px monospace";
                this.ctx.fillText(data.name, x + 15, y + 70);

                // Details (with wrapping)
                this.ctx.font = "14px monospace";
                this.ctx.fillStyle = "#aaa";

                let ly = y + 100;
                const maxDetailWidth = w - 30;
                const maxY = y + h - 20; // Prevent overflow
                data.details.forEach(detail => {
                    if (ly >= maxY) return; // Stop if we're out of space
                    const prefix = '> ';
                    const words = detail.split(' ');
                    let line = prefix;
                    words.forEach(word => {
                        const testLine = line + word + ' ';
                        if (this.ctx.measureText(testLine).width > maxDetailWidth) {
                            if (ly < maxY) {
                                this.ctx.fillText(line, x + 15, ly);
                                ly += 20;
                            }
                            line = '  ' + word + ' '; // Indent continuation
                        } else {
                            line = testLine;
                        }
                    });
                    if (ly < maxY) {
                        this.ctx.fillText(line, x + 15, ly);
                        ly += 25;
                    }
                });
            }

            drawReportCard(report) {
                // Dim bg
                this.ctx.fillStyle = "rgba(0,0,0,0.7)";
                this.ctx.fillRect(0, 0, this.width, this.height);

                const cx = this.width / 2;
                const cy = this.height / 2;
                const w = 400;
                const h = 300;

                // Card body
                this.ctx.fillStyle = "#fff";
                this.ctx.fillRect(cx - w / 2, cy - h / 2, w, h);
                this.ctx.strokeStyle = "#444";
                this.ctx.lineWidth = 4;
                this.ctx.strokeRect(cx - w / 2, cy - h / 2, w, h);

                // Header
                this.ctx.fillStyle = report.result === "SUCCESS" ? "green" : (report.result === "FAILURE" ? "red" : "orange");
                this.ctx.font = "bold 30px monospace";
                this.ctx.textAlign = "center";
                this.ctx.fillText(report.result, cx, cy - 80);

                // Title
                this.ctx.fillStyle = "#222";
                this.ctx.font = "bold 18px monospace";
                this.ctx.fillText(report.questTitle, cx, cy - 40);

                // Body
                this.ctx.font = "14px monospace";
                this.ctx.fillStyle = "#555";

                // Text wrapping logic (simple)
                const words = report.flavorText.split(' ');
                let line = '';
                let ly = cy + 10;
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = this.ctx.measureText(testLine);
                    if (metrics.width > w - 40 && n > 0) {
                        this.ctx.fillText(line, cx, ly);
                        line = words[n] + ' ';
                        ly += 20;
                    } else {
                        line = testLine;
                    }
                }
                this.ctx.fillText(line, cx, ly);

                // Button Prompt
                this.ctx.fillStyle = "#888";
                this.ctx.font = "12px monospace";
                this.ctx.fillText("[Click to Continue]", cx, cy + 120);
            }

            drawDraggedQuest(dragState) {
                const x = dragState.x;
                const y = dragState.y;
                const paperW = 240; // MUCH LARGER
                const paperH = 300;

                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(-0.05);

                // Shadow
                this.ctx.shadowColor = "rgba(0,0,0,0.6)";
                this.ctx.shadowBlur = 20;
                this.ctx.shadowOffsetY = 20;

                // Paper
                this.ctx.fillStyle = "#f0e6d2";
                this.ctx.fillRect(-paperW / 2, -paperH / 2, paperW, paperH);

                // Border
                this.ctx.strokeStyle = "#5d4037";
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(-paperW / 2, -paperH / 2, paperW, paperH);

                // Title
                this.ctx.fillStyle = "#3e2723";
                this.ctx.font = "bold 20px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText(dragState.item.title, 0, -paperH / 2 + 35);

                // Rank
                this.ctx.fillStyle = "#b71c1c";
                this.ctx.font = "bold 32px monospace";
                this.ctx.fillText("RANK: " + dragState.item.rank, 0, -paperH / 2 + 70);

                // Description
                this.ctx.fillStyle = "#3e2723";
                this.ctx.font = "14px monospace";
                this.ctx.textAlign = "left";

                const words = (dragState.item.desc || "").split(' ');
                let line = '';
                let ly = -paperH / 2 + 110;
                const startX = -paperW / 2 + 15;
                const maxWidth = paperW - 30;

                words.forEach(word => {
                    const testLine = line + word + ' ';
                    if (this.ctx.measureText(testLine).width > maxWidth) {
                        this.ctx.fillText(line, startX, ly);
                        line = word + ' ';
                        ly += 20;
                    } else {
                        line = testLine;
                    }
                });
                this.ctx.fillText(line, startX, ly);

                // Tags (with wrapping)
                ly += 30;
                this.ctx.font = "bold 12px monospace";
                this.ctx.fillStyle = "#5d4037";
                this.ctx.fillText("Tags:", startX, ly);
                ly += 18;
                this.ctx.font = "italic 11px monospace";
                if (dragState.item.tags) {
                    const tagText = dragState.item.tags.join(", ");
                    let tagLine = '';
                    const tagWords = tagText.split(', ');
                    tagWords.forEach((tag, idx) => {
                        const testLine = tagLine + (tagLine ? ', ' : '') + tag;
                        if (this.ctx.measureText(testLine).width > maxWidth) {
                            this.ctx.fillText(tagLine, startX, ly);
                            ly += 16;
                            tagLine = tag;
                        } else {
                            tagLine = testLine;
                        }
                    });
                    if (tagLine) this.ctx.fillText(tagLine, startX, ly);
                }

                this.ctx.restore();
            }

            drawAdventurerPlaceholder(hero) {
                const cx = this.width / 2;
                const cy = this.height / 2 - 50;

                // 1. BASE SILHOUETTE
                this.ctx.fillStyle = "rgba(50, 50, 50, 1.0)";

                // Change color/shape based on stats?
                // For now, keep it dark silhouette but add details
                if (hero.visuals.includes("scrawny")) {
                    this.ctx.fillStyle = "rgba(60, 60, 60, 1.0)"; // Lighter/Thinner look notionally
                }

                this.ctx.beginPath();
                // If muscles, make wider
                let width = hero.visuals.includes("muscles") ? 100 : 80;
                if (hero.visuals.includes("scrawny")) width = 60;

                this.ctx.ellipse(cx, cy + 50, width, 180, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // 2. RENDER VISUAL TELLS (The Clues)

                // GLOWING EYES
                if (hero.visuals.includes("glowing_eyes")) {
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = "cyan";
                    this.ctx.fillStyle = "cyan";
                    this.ctx.beginPath();
                    this.ctx.arc(cx - 20, cy - 80, 5, 0, Math.PI * 2); // Left Eye
                    this.ctx.arc(cx + 20, cy - 80, 5, 0, Math.PI * 2); // Right Eye
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }

                // JEWELRY (Gold necklace/chain)
                if (hero.visuals.includes("jewelry")) {
                    this.ctx.strokeStyle = "gold";
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy - 30, 40, 0, Math.PI, false); // Necklace arc
                    this.ctx.stroke();
                    // Gem
                    this.ctx.fillStyle = "red";
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy + 10, 8, 0, Math.PI * 2); // Pendant
                    this.ctx.fill();
                }

                // PRISTINE ARMOR (Shiny)
                if (hero.visuals.includes("pristine_armor")) {
                    this.ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx - 30, cy);
                    this.ctx.lineTo(cx + 30, cy + 20);
                    this.ctx.lineTo(cx - 30, cy + 40);
                    this.ctx.fill(); // Shine streak
                }

                // RUSTY GEAR (Brown splotches)
                if (hero.visuals.includes("rusty_gear")) {
                    this.ctx.fillStyle = "#8b4513";
                    this.ctx.fillRect(cx - 40, cy + 20, 10, 10);
                    this.ctx.fillRect(cx + 30, cy + 60, 15, 15);
                }

                // BANDAGED (White strips)
                if (hero.visuals.includes("bandaged")) {
                    this.ctx.strokeStyle = "#eee";
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx - 50, cy + 50);
                    this.ctx.lineTo(cx - 20, cy + 60);
                    this.ctx.stroke(); // Arm bandage

                    this.ctx.beginPath();
                    this.ctx.moveTo(cx + 20, cy - 100);
                    this.ctx.lineTo(cx + 50, cy - 90);
                    this.ctx.stroke(); // Head bandage
                }

                // 3. SHAKING ANIMATION (Procedural)
                let offsetX = 0;
                if (hero.visuals.includes("shaking")) {
                    offsetX = (Math.random() - 0.5) * 5; // Jitter
                }

                // Re-draw Name with Jitter
                this.ctx.fillStyle = "#ffffff";
                this.ctx.font = "bold 20px 'MedievalSharp', monospace";
                this.ctx.textAlign = "center";
                this.ctx.shadowColor = "black";
                this.ctx.shadowBlur = 4;
                this.ctx.fillText(hero.name, cx + offsetX, cy - 150);
                this.ctx.shadowBlur = 0;

                // Question Mark (if mystery, maybe remove this eventually?)
                this.ctx.fillStyle = "#FFD700";
                this.ctx.font = "bold 48px monospace";
                this.ctx.fillText("?", cx, cy + 60);
            }

            drawQuestBoard(quests) {
                if (!quests || quests.length === 0) return;

                // Board Area (Calculated)
                const startX = 640;
                const startY = 220;
                const paperW = 100;
                const paperH = 130;
                const gap = 15;
                const cols = 3;

                this.ctx.save();
                this.ctx.shadowColor = "rgba(0,0,0,0.5)";
                this.ctx.shadowBlur = 2;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 2;

                quests.forEach((quest, index) => {
                    // Skip if currently being dragged (implied by Input logic, need to check logic)
                    if (gameState.dragState && gameState.dragState.item === quest) return;

                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    const x = startX + col * (paperW + gap);
                    const y = startY + row * (paperH + gap) + (index % 2 * 5); // Slight stagger

                    // Paper Background
                    this.ctx.fillStyle = "#f0e6d2"; // Parchment
                    this.ctx.fillRect(x, y, paperW, paperH);

                    // Title (readable)
                    this.ctx.fillStyle = "#3e2723";
                    this.ctx.font = "bold 11px monospace";
                    this.ctx.textAlign = "center";
                    const words = quest.title.split(' ');
                    if (words.length > 2) {
                        this.ctx.fillText(words.slice(0, 2).join(' '), x + paperW / 2, y + 25);
                        this.ctx.fillText(words.slice(2).join(' '), x + paperW / 2, y + 40);
                    } else {
                        this.ctx.fillText(quest.title, x + paperW / 2, y + 30);
                    }

                    // Rank Label (Large)
                    this.ctx.fillStyle = "#b71c1c";
                    this.ctx.font = "bold 32px monospace";
                    this.ctx.fillText(quest.rank, x + paperW / 2, y + paperH / 2 + 20);

                    // Seal at bottom
                    this.ctx.fillStyle = (quest.rank === 'S' || quest.rank === 'A') ? "#8b0000" : "#4a3728";
                    this.ctx.beginPath();
                    this.ctx.arc(x + paperW / 2, y + paperH - 20, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.restore();
            }
        }

        // 5. MAIN LOOP
        const canvas = document.getElementById('game-canvas');
        canvas.width = 1024;
        canvas.height = 768;
        const renderer = new Renderer(canvas);

        let gameState = {
            screen: 'START', // START, GAME, REPORT
            day: 1,
            currentAdventurer: null,
            pendingReports: [] // Stores results from the day
        };

        function startGame() {
            gameState.screen = 'GAME';
            startNewDay();
        }

        function startNewDay() {
            gameState.day++;
            gameState.pendingReports = []; // Clear previous day's reports

            // Generate Adventurer
            gameState.currentAdventurer = AdventurerGenerator.generate(gameState.day);

            // Load Quests (from Data Layer)
            if (window.GameData && window.GameData.Quests) {
                // Shuffle and pick 3-6
                const count = Math.floor(Math.random() * 4) + 3;
                gameState.quests = [...window.GameData.Quests].sort(() => 0.5 - Math.random()).slice(0, count);
            } else {
                console.warn("Quests not loaded!");
                gameState.quests = [];
            }
        }

        async function init() {
            document.getElementById('debug-console').style.display = 'none';
            await renderer.loadAssets();

            // Initialize Systems
            gameState.economy = new window.GameSystems.EconomyManager(100);
            gameState.inspector = new window.GameSystems.Inspector();
            gameState.persistence = new window.GameSystems.PersistenceManager(); // NEW
            const input = new window.GameSystems.InputController(canvas, gameState);

            // Event: Next Adventurer (Same Day)
            document.addEventListener('nextAdventurer', () => {
                // Chance to return old adventurer?
                let returningParams = null;
                // 30% chance if we have history
                if (gameState.persistence && Math.random() < 0.3) {
                    returningParams = gameState.persistence.getReturningAdventurer();
                }

                if (returningParams) {
                    console.log("RETURNING HERO:", returningParams.name);
                    gameState.currentAdventurer = new window.GameSystems.Adventurer(returningParams);
                    // Force refresh visuals in case traits changed
                    // (Constructor calls generateVisuals, so it should be fine if traits are passed correctly)
                } else {
                    gameState.currentAdventurer = AdventurerGenerator.generate(gameState.day);
                }
            });

            // Event: Manual End Day
            document.addEventListener('endDayManual', () => {
                // Process Upkeep
                const upkeep = gameState.economy.processDailyUpkeep();
                if (upkeep.bankrupt) {
                    alert("GAME OVER: You ran out of gold!");
                    location.reload();
                    return;
                }

                // Switch to Report View instead of immediately starting new day
                gameState.screen = 'REPORT';
                gameState.reportOpenedAt = Date.now(); // Prevent immediate click-through
            });

            // Input (Keyboard still useful for debug/start)
            window.addEventListener('keydown', (e) => {
                if (gameState.screen === 'START') {
                    if (e.code === 'Space' || e.code === 'Enter') startGame();
                } else if (gameState.screen === 'GAME') {
                    // if (e.code === 'Space') startNewDay(); // Disable space to skip
                } else if (gameState.screen === 'REPORT') {
                    if (e.code === 'Space') {
                        gameState.screen = 'GAME';
                        startNewDay();
                    }
                }
            });

            // Mouse Click for Start and Report
            canvas.addEventListener('click', () => {
                if (gameState.screen === 'START') startGame();
                else if (gameState.screen === 'REPORT') {
                    // Prevent click-through: require 300ms delay after report opens
                    if (gameState.reportOpenedAt && Date.now() - gameState.reportOpenedAt < 300) {
                        return; // Ignore click
                    }
                    gameState.screen = 'GAME';
                    startNewDay();
                }
            });

            gameLoop();
        }

        function gameLoop() {
            renderer.draw(gameState);
            requestAnimationFrame(gameLoop);
        }

        // Start immediately
        init();
    </script>
    <!-- REMOVED script.js import -->
</body>

</html>