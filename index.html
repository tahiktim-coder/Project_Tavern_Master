<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guild Master</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <script src="js/data/traitData.js"></script>
    <script src="js/data/questData.js"></script>
    <script src="js/models/Adventurer.js"></script>
    <script src="js/systems/Resolution.js"></script>
    <script src="js/models/VisualTraits.js"></script>
    <script src="js/models/VisualTraits.js"></script>
    <script src="js/systems/Inspector.js"></script>
    <script src="js/systems/Persistence.js"></script>
    <script src="js/systems/Economy.js"></script>
    <script src="js/systems/Input.js"></script>
</head>

<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-layer"></div>
        <div id="debug-console"
            style="position: absolute; top: 0; left: 0; color: lime; background: rgba(0,0,0,0.8); font-family: monospace; padding: 10px; pointer-events: none; width: 100%; height: 50%; overflow: hidden; display: none;">
        </div>
    </div>
    <!-- Debug Console Script -->
    <script>
        const debugConsole = document.getElementById('debug-console');
        debugConsole.style.display = 'block'; // Make visible immediately
        debugConsole.innerHTML = "<div>Status: Debug Console Loaded...</div>";

        function logToScreen(msg, color = 'white') {
            debugConsole.innerHTML += `<div style="color: ${color};">${msg}</div>`;
        }

        // Global Error Handler
        window.onerror = function (msg, url, line, col, error) {
            const fileName = url ? url.split('/').pop() : 'unknown';
            logToScreen(`ERROR: ${msg} <br> File: ${fileName} : Line ${line}`, 'red');
            return false;
        };

        // Async Promise Error Handler
        window.addEventListener('unhandledrejection', function (event) {
            logToScreen(`ASYNC ERROR: ${event.reason}`, 'orange');
        });

        // Console Log Override
        const originalLog = console.log;
        console.log = function (...args) {
            originalLog.apply(console, args);
            logToScreen(`LOG: ${args.join(' ')}`, '#00FF00');
        };

        logToScreen("Waiting for module to load...", 'yellow');

        // 1. DATA (Previously adventurerData.js)
        const ADVENTURER_DATA = {
            archetypes: {
                MARTIAL: {
                    name: "Martial",
                    classes: [
                        { id: "knight", name: "Knight-Errant", traits: ["Honorbound", "Arrogant"], stats: { str: [8, 10], int: [2, 5], dex: [4, 6] } },
                        { id: "barbarian", name: "Barbarian", traits: ["Battle-Rage", "Illiterate"], stats: { str: [9, 10], int: [1, 3], dex: [5, 7] } },
                        { id: "mercenary", name: "Mercenary", traits: ["Greedy", "Pragmatic"], stats: { str: [6, 8], int: [4, 6], dex: [5, 7] } },
                        { id: "pit_fighter", name: "Pit Fighter", traits: ["Sadist", "Showman"], stats: { str: [7, 9], int: [2, 4], dex: [7, 9] } },
                        { id: "guard", name: "Town Guard", traits: ["Lazy", "Corrupt"], stats: { str: [5, 7], int: [3, 5], dex: [4, 6] } },
                        { id: "ronin", name: "Ronin", traits: ["Wanderer", "Disciplined"], stats: { str: [7, 9], int: [4, 6], dex: [8, 10] } }
                    ]
                },
                ARCANE: {
                    name: "Arcane",
                    classes: [
                        { id: "battle_mage", name: "Battle Mage", traits: ["Pyromaniac", "Short-Tempered"], stats: { str: [4, 6], int: [8, 10], dex: [4, 6] } },
                        { id: "scholar", name: "Scholar", traits: ["Cowardly", "Curious"], stats: { str: [2, 4], int: [9, 10], dex: [3, 5] } },
                        { id: "necromancer", name: "Necromancer", traits: ["Outcast", "Creepy"], stats: { str: [3, 5], int: [8, 10], dex: [3, 5] } },
                        { id: "illusionist", name: "Illusionist", traits: ["Liar", "Kleptomaniac"], stats: { str: [3, 5], int: [7, 9], dex: [8, 10] } },
                        { id: "elementalist", name: "Elementalist", traits: ["Volatile", "Connected"], stats: { str: [4, 6], int: [7, 9], dex: [5, 7] } },
                        { id: "hedge_wizard", name: "Hedge Wizard", traits: ["Helpful", "Unlicensed"], stats: { str: [3, 5], int: [5, 7], dex: [4, 6] } }
                    ]
                },
                CUNNING: {
                    name: "Cunning",
                    classes: [
                        { id: "rogue", name: "Rogue", traits: ["Greedy", "Traitor"], stats: { str: [3, 5], int: [5, 7], dex: [8, 10] } },
                        { id: "ranger", name: "Ranger", traits: ["Loner", "Nature-Lover"], stats: { str: [5, 7], int: [4, 6], dex: [8, 10] } },
                        { id: "bard", name: "Bard", traits: ["Drunk", "Flirtatious"], stats: { str: [3, 5], int: [6, 8], dex: [7, 9] } },
                        { id: "assassin", name: "Assassin", traits: ["Cold-Blooded", "Contract_Killer"], stats: { str: [5, 7], int: [6, 8], dex: [9, 10] } },
                        { id: "treasure_hunter", name: "Treasure Hunter", traits: ["Obsessive", "Unlucky"], stats: { str: [4, 6], int: [5, 8], dex: [7, 9] } },
                        { id: "spy", name: "Spy", traits: ["Double Agent", "Paranoid"], stats: { str: [4, 6], int: [8, 10], dex: [6, 8] } }
                    ]
                },
                DIVINE: {
                    name: "Divine",
                    classes: [
                        { id: "cleric", name: "Cleric", traits: ["Zealot", "Pacifist"], stats: { str: [5, 7], int: [7, 9], dex: [3, 5] } },
                        { id: "paladin", name: "Paladin", traits: ["Lawful Stupid", "Judgemental"], stats: { str: [8, 10], int: [4, 6], dex: [4, 6] } },
                        { id: "druid", name: "Druid", traits: ["Feral", "Territorial"], stats: { str: [5, 7], int: [6, 8], dex: [6, 8] } },
                        { id: "monk", name: "Monk", traits: ["Vow of Silence", "Disciplined"], stats: { str: [7, 9], int: [6, 8], dex: [9, 10] } },
                        { id: "cultist", name: "Cultist", traits: ["Insane", "Doomed"], stats: { str: [4, 6], int: [5, 7], dex: [5, 7] } }
                    ]
                }
            }
        };

        // 2. MODEL (Imported from js/models/Adventurer.js)
        // class Adventurer removed to avoid duplicate declaration error


        // 3. GENERATOR (Previously adventurerGenerator.js)
        class AdventurerGenerator {
            static generate(day = 1) {
                const archetypeKeys = Object.keys(ADVENTURER_DATA.archetypes);
                const archetypeKey = archetypeKeys[Math.floor(Math.random() * archetypeKeys.length)];
                const archetypeData = ADVENTURER_DATA.archetypes[archetypeKey];
                const charClass = archetypeData.classes[Math.floor(Math.random() * archetypeData.classes.length)];

                const stats = {
                    str: this.randomRange(charClass.stats.str[0], charClass.stats.str[1]),
                    int: this.randomRange(charClass.stats.int[0], charClass.stats.int[1]),
                    dex: this.randomRange(charClass.stats.dex[0], charClass.stats.dex[1]),
                    vit: this.randomRange(3, 8)
                };

                const traits = [...charClass.traits];

                // Pick race based on class
                const race = this.pickRaceForClass(charClass.id);

                const equipment = { mainHand: "Basic Weapon", armor: "Basic Armor" };
                const names = ["Garrett", "Lyra", "Thorn", "Elara", "Ragnar", "Sylas"];
                const name = names[Math.floor(Math.random() * names.length)] + " the " + charClass.name;

                return new Adventurer({
                    name: name,
                    archetype: archetypeKey,
                    classId: charClass.id,
                    race: race, // NEW: Add race
                    stats: stats,
                    traits: traits,
                    equipment: equipment
                });
            }

            static pickRaceForClass(classId) {
                // Map to maximize portrait usage - group similar classes
                const raceMap = {
                    // MARTIAL - Use human_warrior or orc_barbarian
                    warrior: 'human',  // human_warrior.png
                    knight: 'human',   // human_warrior.png
                    pit_fighter: 'human', // human_warrior.png
                    mercenary: 'human', // human_warrior.png
                    ronin: 'human',    // human_warrior.png
                    guard: 'human',    // human_warrior.png  
                    barbarian: 'orc',  // orc_barbarian.png (always orc now)

                    // ARCANE - Use elf_mage or human_necromancer
                    battle_mage: 'elf',    // elf_mage.png
                    scholar: 'elf',        // elf_mage.png
                    illusionist: 'elf',    // elf_mage.png
                    elementalist: 'elf',   // elf_mage.png
                    hedge_wizard: 'elf',   // elf_mage.png
                    necromancer: 'human',  // human_necromancer.png
                    cultist: 'human',      // human_necromancer.png

                    // CUNNING - Use human_rogue or elf_ranger
                    rogue: 'human',        // human_rogue.png
                    assassin: 'human',     // human_rogue.png
                    spy: 'human',          // human_rogue.png
                    treasure_hunter: 'human', // human_rogue.png
                    bard: 'human',         // human_rogue.png (close enough)
                    ranger: 'elf',         // elf_ranger.png

                    // DIVINE - Use human_cleric or dwarf_paladin
                    cleric: 'human',   // human_cleric.png
                    monk: 'human',     // human_cleric.png (both holy)
                    druid: 'elf',      // elf_ranger.png (nature themed)
                    paladin: 'dwarf'   // dwarf_paladin.png
                };

                return raceMap[classId] || 'human';
            }

            static randomRange(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
        }

        // 4. RENDERER (Previously Renderer.js)
        class Renderer {
            constructor(canvas) {
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                this.assets = {};
                this.portraits = {}; // NEW: Cache for character portraits
                this.isLoaded = false;
            }

            loadAssets() {
                return new Promise((resolve) => {
                    let loaded = 0;
                    const checkDone = () => { if (++loaded >= 2) resolve(); };

                    // Start Screen Background (New Optimized Title Screen)
                    const imgStart = new Image();
                    imgStart.src = 'assets/title_screen.png';
                    imgStart.onload = () => { this.assets['bg_start'] = imgStart; checkDone(); };
                    imgStart.onerror = () => { logToScreen("Start BG Failed", 'orange'); checkDone(); };

                    // Game Screen Background (Papers Please POV Counter View)
                    const imgGame = new Image();
                    imgGame.src = 'assets/counter_view.png';
                    imgGame.onload = () => { this.assets['bg_game'] = imgGame; logToScreen("Game BG Loaded", 'lime'); checkDone(); };
                    imgGame.onerror = () => { logToScreen("Game BG Failed", 'orange'); checkDone(); };
                });
            }

            draw(gameState) {
                this.ctx.clearRect(0, 0, this.width, this.height);

                // Select Background based on Screen State
                let bgKey = gameState.screen === 'START' ? 'bg_start' : 'bg_game';
                if (this.assets[bgKey]) {
                    this.ctx.drawImage(this.assets[bgKey], 0, 0, this.width, this.height);
                } else {
                    this.ctx.fillStyle = "#3e3e3e";
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }

                if (gameState.screen === 'START') {
                    this.drawStartScreen();
                } else if (gameState.screen === 'GAME') {
                    this.drawGameScreen(gameState);
                } else if (gameState.screen === 'REPORT') {
                    this.drawMorningReportV2(gameState);
                } else if (gameState.screen === 'ROSTER') {
                    this.drawRosterScreen(gameState);
                }
            }

            drawMorningReportV2(gameState) {
                // 1. Background (Darkened Tavern)
                this.ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
                this.ctx.fillRect(0, 0, this.width, this.height);

                // 2. The Ledger (Large Scroll)
                const sheetW = 900;
                const sheetH = 680;
                const bx = (this.width - sheetW) / 2;
                const by = (this.height - sheetH) / 2;

                // Paper Background
                this.ctx.fillStyle = "#f5e6d3";
                this.ctx.fillRect(bx, by, sheetW, sheetH);

                // Border
                this.ctx.strokeStyle = "#4a321e";
                this.ctx.lineWidth = 10;
                this.ctx.strokeRect(bx, by, sheetW, sheetH);
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(bx + 15, by + 15, sheetW - 30, sheetH - 30);

                // 3. Header
                this.ctx.fillStyle = "#3e2723";
                this.ctx.font = "bold 40px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText("Guild Daily Ledger", this.width / 2, by + 60);

                this.ctx.font = "26px 'MedievalSharp', cursive";
                this.ctx.fillText("Day " + gameState.day, this.width / 2, by + 95);

                // Divider
                this.ctx.beginPath();
                this.ctx.moveTo(bx + 100, by + 110);
                this.ctx.lineTo(bx + sheetW - 100, by + 110);
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                // 4. Entries
                let cy = by + 140;
                const startX = bx + 80;

                if (gameState.pendingReports && gameState.pendingReports.length > 0) {
                    const count = gameState.pendingReports.length;
                    // Dynamic Row Height Logic
                    // Available height: 410px (Reduced to fit footer). Min 55, Max 85.
                    const availableH = 410;
                    const rowHeight = Math.max(55, Math.min(85, availableH / count));

                    gameState.pendingReports.forEach((report, idx) => {
                        const hero = report.adventurer || {};

                        // Alternating Background Strip
                        if (idx % 2 === 0) {
                            this.ctx.fillStyle = "rgba(139, 69, 19, 0.05)"; // Very faint brown
                            this.ctx.fillRect(bx + 20, cy - rowHeight / 2 + 10, sheetW - 40, rowHeight);
                        }

                        // Icons & Colors
                        let icon = "â“";
                        let color = "#333";
                        let statusText = report.result;

                        if (report.result === "SUCCESS") {
                            icon = "âœ”"; color = "#2e7d32";

                        } else if (hero.isDead) { // DEATH Check
                            icon = "ðŸ’€"; color = "#b71c1c"; statusText = "KILLED";
                        } else if (hero.injuries && hero.injuries.length > 0) {
                            icon = "âš "; color = "#e65100"; statusText = "INJURED";
                        } else if (report.result === "FAILURE") {
                            icon = "âœ–"; color = "#c62828";
                        } else if (report.result === "MIXED") {
                            icon = "âˆ’"; color = "#f57c00"; statusText = "Mixed";
                        }

                        // A. Icon
                        this.ctx.textAlign = "center";
                        this.ctx.font = `bold ${Math.min(30, rowHeight / 2)}px monospace`;
                        this.ctx.fillStyle = color;
                        this.ctx.fillText(icon, startX, cy + 8);

                        // B. Quest & Status
                        this.ctx.textAlign = "left";
                        this.ctx.font = "bold 20px 'MedievalSharp', cursive"; // Slightly smaller
                        this.ctx.fillText(`[${statusText}] ${report.questTitle}`, startX + 50, cy);

                        // C. Hero Name
                        this.ctx.font = "italic 16px 'MedievalSharp', cursive";
                        this.ctx.fillStyle = "#5d4037";
                        this.ctx.fillText(report.adventurerName, startX + 60, cy + 20);

                        // D. Flavor/Consequence
                        this.ctx.font = "13px 'MedievalSharp', cursive";
                        this.ctx.fillStyle = "#3e2723";
                        let flavor = report.flavorText || "";
                        if (hero.isDead) flavor = "âœ " + flavor;
                        else if (hero.injuries && hero.injuries.length > 0) {
                            const inj = hero.injuries[hero.injuries.length - 1];
                            const dur = inj.duration === -1 ? 'Permanent' : inj.duration + 'd';
                            flavor = `âš  ${inj.name} (${dur}) - ${flavor}`;
                        }
                        // Truncate based on width
                        if (flavor.length > 75) flavor = flavor.substring(0, 72) + "...";
                        this.ctx.fillText(flavor, startX + 60, cy + 36);

                        // E. Gold
                        const gold = report.goldEarned || 0;
                        this.ctx.textAlign = "right";
                        this.ctx.font = "bold 22px 'MedievalSharp', cursive";
                        this.ctx.fillStyle = gold > 0 ? "#f9a825" : "#9e9e9e";
                        this.ctx.fillText(gold > 0 ? `+${gold} G` : "0 G", bx + sheetW - 80, cy + 5);

                        cy += rowHeight;
                    });
                } else {
                    this.ctx.fillStyle = "#8d6e63";
                    this.ctx.fillText("No guild activity recorded.", this.width / 2, cy + 50);
                }

                // TOTALS Calculation
                let totalGold = 0;
                if (gameState.pendingReports) {
                    gameState.pendingReports.forEach(r => totalGold += (r.goldEarned || 0));
                }
                const upkeep = gameState.lastUpkeep ? gameState.lastUpkeep.paid : 0;
                const net = totalGold - upkeep;

                // Footer Area
                const footerY = by + sheetH - 150; // Moved UP significantly to avoid Button overlap

                // Line Separation
                this.ctx.beginPath();
                this.ctx.moveTo(bx + 50, footerY);
                this.ctx.lineTo(bx + sheetW - 50, footerY);
                this.ctx.strokeStyle = "#4a321e";
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                // Financial Summary
                this.ctx.textAlign = "right";
                const valX = bx + sheetW - 100;
                const labX = valX - 120;
                let fy = footerY + 30;

                // 1. Gross
                this.ctx.font = "20px monospace";
                this.ctx.fillStyle = "#5d4037"; // Brown
                this.ctx.fillText("Gross Revenue:", labX, fy);
                this.ctx.fillStyle = "#2e7d32"; // Green
                this.ctx.fillText(`+${totalGold} G`, valX, fy);

                // 2. Upkeep
                fy += 25;
                this.ctx.fillStyle = "#5d4037";
                this.ctx.fillText("Daily Upkeep:", labX, fy);
                this.ctx.fillStyle = "#c62828"; // Red
                this.ctx.fillText(`-${upkeep} G`, valX, fy);

                // 3. Net
                fy += 35;
                this.ctx.font = "bold 28px 'MedievalSharp', cursive";
                this.ctx.fillStyle = "#3e2723";
                this.ctx.fillText("Net Profit:", labX, fy);
                this.ctx.fillStyle = net >= 0 ? "#FFD700" : "#d32f2f";
                this.ctx.fillText(`${net >= 0 ? '+' : ''}${net} G`, valX, fy);

                // BUTTON
                // Centered button at bottom
                const btnW = 220;
                const btnH = 60;
                const btnX = this.width / 2 - btnW / 2;
                const btnY = by + sheetH - 40; // Overlaps bottom edge slightly for effect

                // Button Shadow
                this.ctx.fillStyle = "rgba(0,0,0,0.4)";
                this.ctx.fillRect(btnX + 5, btnY + 5, btnW, btnH);

                // Button Body
                this.ctx.fillStyle = "#b71c1c"; // Red wax
                this.ctx.fillRect(btnX, btnY, btnW, btnH);
                this.ctx.strokeStyle = "#e53935";
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(btnX, btnY, btnW, btnH);

                this.ctx.fillStyle = "#fff";
                this.ctx.font = "bold 24px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText("NEXT DAY", this.width / 2, btnY + 35);

                this.ctx.font = "16px monospace";
                this.ctx.fillStyle = "#ffcdd2";
                this.ctx.fillText("(Press SPACE)", this.width / 2, btnY + 80);
            }

            drawStartScreen() {
                // Dim background
                this.ctx.fillStyle = "rgba(0,0,0,0.6)";
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Title
                this.ctx.fillStyle = "#FFD700";
                this.ctx.font = "bold 60px monospace";
                this.ctx.textAlign = "center";
                this.ctx.shadowColor = "black";
                this.ctx.shadowBlur = 10;
                this.ctx.fillText("GUILD MASTER", this.width / 2, this.height / 2 - 50);
                this.ctx.shadowBlur = 0;

                // Play Button
                this.ctx.fillStyle = "#8B4513";
                this.ctx.fillRect(this.width / 2 - 100, this.height / 2 + 50, 200, 60);
                this.ctx.border = "2px solid #fff";

                this.ctx.fillStyle = "#fff";
                this.ctx.font = "30px monospace";
                this.ctx.fillText("PLAY", this.width / 2, this.height / 2 + 90);

                this.ctx.font = "16px monospace";
                this.ctx.fillStyle = "#ccc";
                this.ctx.fillText("[Press SPACE or Click]", this.width / 2, this.height / 2 + 150);
            }

            drawRosterScreen(gameState) {
                // Background (Dark Overlay)
                this.ctx.fillStyle = "rgba(20, 10, 5, 0.95)";
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Border
                this.ctx.strokeStyle = "#FFD700";
                this.ctx.lineWidth = 4;
                this.ctx.strokeRect(50, 50, this.width - 100, this.height - 100);

                // Header
                this.ctx.fillStyle = "#FFD700";
                this.ctx.font = "bold 50px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.shadowColor = "black";
                this.ctx.shadowBlur = 10;
                this.ctx.fillText("Guild Roster", this.width / 2, 110);
                this.ctx.shadowBlur = 0;

                // Scrollable List area (simplified for now as just a list)
                this.ctx.font = "24px 'MedievalSharp', cursive";
                this.ctx.textAlign = "left";

                // Get Roster
                const members = gameState.persistence ? gameState.persistence.roster : [];

                if (!members || members.length === 0) {
                    this.ctx.fillStyle = "#8d6e63";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("The guild has no members yet.", this.width / 2, this.height / 2);
                } else {
                    let y = 180;
                    const xName = 150;
                    const xClass = 450;
                    const xStatus = 750;

                    // Table Headers
                    this.ctx.fillStyle = "#FFB74D";
                    this.ctx.fillText("Name", xName, 150);
                    this.ctx.fillText("Class (Lvl)", xClass, 150);
                    this.ctx.fillText("Status", xStatus, 150);

                    this.ctx.beginPath();
                    this.ctx.moveTo(100, 160);
                    this.ctx.lineTo(this.width - 100, 160);
                    this.ctx.strokeStyle = "#5d4037";
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();

                    // Entries
                    members.forEach((m, idx) => {
                        if (y > this.height - 100) return; // Clip

                        // Alternate rows
                        if (idx % 2 === 0) {
                            this.ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
                            this.ctx.fillRect(60, y - 25, this.width - 120, 35);
                        }

                        this.ctx.fillStyle = "#e0e0e0";
                        this.ctx.fillText(m.name, xName, y);
                        this.ctx.fillText(`${m.class} (${m.level})`, xClass, y);

                        // Status Color
                        let status = "Ready";
                        let color = "#4caf50"; // Green

                        if (m.isDead) { status = "Accident"; color = "red"; }
                        else if (m.injuries && m.injuries.length > 0) {
                            const inj = m.injuries[0]; // Get first injury
                            const dur = (inj && inj.duration !== undefined) ? inj.duration + "d" : "?";
                            status = "Injured (" + dur + ")";
                            color = "#ff9800"; // Orange
                        } else if (m.isAssigned) {
                            status = "On Quest";
                            color = "#2196f3"; // Blue
                        }

                        this.ctx.fillStyle = color;
                        this.ctx.fillText(status, xStatus, y);
                        y += 40;
                    });
                }

                // Footer
                if (!gameState.rosterDetailMember) {
                    this.ctx.fillStyle = "#888";
                    this.ctx.font = "16px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("[Click a member to manage]", this.width / 2, this.height - 20);
                }

                // Draw Detail Modal if active
                if (gameState.rosterDetailMember) {
                    this.drawRosterDetail(gameState.rosterDetailMember);
                }
            }

            drawRosterDetail(member) {
                // Dim background
                this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Modal Window
                const w = 600;
                const h = 550;
                const x = (this.width - w) / 2;
                const y = (this.height - h) / 2;

                this.ctx.fillStyle = "#2c1e14"; // dary wood
                this.ctx.fillRect(x, y, w, h);
                this.ctx.strokeStyle = "#FFD700";
                this.ctx.lineWidth = 4;
                this.ctx.strokeRect(x, y, w, h);

                // Header
                this.ctx.fillStyle = "#FFD700";
                this.ctx.font = "bold 36px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText(member.name, x + w / 2, y + 50);

                // Portrait (Left)
                const pSize = 180;
                const px = x + 40;
                const py = y + 80;
                // Draw frame
                this.ctx.strokeStyle = "#6d4c41";
                this.ctx.strokeRect(px, py, pSize, pSize);
                // Draw Image
                const portrait = this.getPortrait(member);
                if (portrait) {
                    this.ctx.drawImage(portrait, px, py, pSize, pSize);
                }

                // Stats (Right)
                this.ctx.textAlign = "left";
                this.ctx.font = "24px monospace";
                this.ctx.fillStyle = "#fff";
                let sy = y + 100;
                const sx = x + 250;

                this.ctx.fillText(`Class: ${member.classId}`, sx, sy); sy += 35;
                this.ctx.fillText(`Race:  ${member.race}`, sx, sy); sy += 35;
                sy += 10;
                this.ctx.fillStyle = "#e0e0e0";
                this.ctx.fillText(`STR: ${member.stats.str}`, sx, sy); sy += 30;
                this.ctx.fillText(`DEX: ${member.stats.dex}`, sx, sy); sy += 30;
                this.ctx.fillText(`INT: ${member.stats.int}`, sx, sy); sy += 30;
                this.ctx.fillText(`VIT: ${member.stats.vit}`, sx, sy); sy += 30;

                // Injuries / Traits
                // VISUALS (Inspection Data)
                sy = y + 290;

                this.ctx.fillStyle = "#81d4fa"; // Light Blue (Scanner color)
                this.ctx.font = "bold 16px monospace";

                if (member.visuals && member.visuals.length > 0) {
                    member.visuals.forEach(tag => {
                        const text = (window.GameData.VisualTraits && window.GameData.VisualTraits[tag]) ? window.GameData.VisualTraits[tag] : tag;
                        this.ctx.fillText("> " + text, x + 40, sy);
                        sy += 25;
                    });
                } else {
                    this.ctx.fillText("> Standard appearance.", x + 40, sy);
                    sy += 25;
                }

                // Traits
                sy += 10;
                this.ctx.fillStyle = "#FFB74D";
                this.ctx.font = "bold 20px 'MedievalSharp', cursive";
                this.ctx.fillText("Traits: " + member.traits.join(", "), x + 40, sy);

                sy += 30;
                if (member.injuries && member.injuries.length > 0) {
                    this.ctx.fillStyle = "#ff5252";
                    const inj = member.injuries[0];
                    this.ctx.fillText(`INJURY: ${inj.name} (-${inj.duration}d)`, x + 40, sy);
                } else {
                    this.ctx.fillStyle = "#66bb6a";
                    this.ctx.fillText("Condition: Healthy", x + 40, sy);
                }

                // ACTIONS
                const btnY = y + h - 80;

                // HEAL BUTTON (Only if injured)
                if (member.injuries && member.injuries.length > 0) {
                    const healPrice = 50;
                    this.ctx.fillStyle = "#2e7d32";
                    this.ctx.fillRect(x + 40, btnY, 160, 50);
                    this.ctx.fillStyle = "#fff";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "bold 18px monospace";
                    this.ctx.fillText(`TREAT (-${healPrice}G)`, x + 120, btnY + 30);
                    // Hitbox: x+40, btnY, 160, 50
                }

                // FIRE BUTTON
                this.ctx.fillStyle = "#c62828";
                this.ctx.fillRect(x + w - 180, btnY, 140, 50);
                this.ctx.fillStyle = "#fff";
                this.ctx.textAlign = "center";
                this.ctx.font = "bold 18px monospace";
                this.ctx.fillText("FIRE", x + w - 110, btnY + 30);

                // CLOSE BUTTON (Top Right)
                this.ctx.fillStyle = "#b71c1c";
                this.ctx.fillRect(x + w - 40, y, 40, 40);
                this.ctx.fillStyle = "#fff";
                this.ctx.fillText("X", x + w - 20, y + 28);
            }

            drawGameScreen(gameState) {
                // Draw Quests on Board
                if (gameState.quests) {
                    this.drawQuestBoard(gameState.quests);
                }

                // Draw Adventurer
                const hero = gameState.currentAdventurer;
                if (hero) {
                    this.drawAdventurerPlaceholder(hero);
                }

                // UI: Gold & Day - WITH PROPER BACKGROUNDS
                // Dark panel background for contrast
                this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                this.ctx.fillRect(10, 10, 180, 75);

                // Gold border accent
                this.ctx.strokeStyle = "#FFD700";
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(10, 10, 180, 75);

                // Gold text
                this.ctx.fillStyle = "#FFD700";
                this.ctx.font = "bold 22px monospace";
                this.ctx.textAlign = "left";
                this.ctx.fillText(`Gold: ${gameState.economy.gold} `, 20, 38);

                // Day text
                this.ctx.fillStyle = "#FFFFFF";
                this.ctx.fillText(`Day: ${gameState.day} `, 20, 68);

                // UI: Guild Roster Button
                const rosterBtnX = 10;
                const rosterBtnY = 95;
                const rosterBtnW = 180;
                const rosterBtnH = 50;

                this.ctx.fillStyle = "#4a321e"; // Wood
                this.ctx.fillRect(rosterBtnX, rosterBtnY, rosterBtnW, rosterBtnH);
                this.ctx.strokeStyle = "#8d6e63"; // Lighter wood border
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(rosterBtnX, rosterBtnY, rosterBtnW, rosterBtnH);

                this.ctx.fillStyle = "#f5f5f5";
                this.ctx.font = "bold 18px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText("GUILD ROSTER", rosterBtnX + rosterBtnW / 2, rosterBtnY + 32);

                // UI: End Day (Hanging Sign Top Right)
                // Draw Rope
                this.ctx.strokeStyle = "#5d4037";
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(925, 0);
                this.ctx.lineTo(925, 30);
                this.ctx.stroke();

                // Draw Sign Board
                this.ctx.fillStyle = "#4a321e"; // Wood
                this.ctx.fillRect(860, 30, 130, 50);
                this.ctx.fillStyle = "#3e2723"; // Border
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(860, 30, 130, 50);

                this.ctx.fillStyle = "#d7ccc8"; // Text
                this.ctx.font = "bold 18px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText("END DAY", 925, 62);


                // UI: Action Buttons (Bottom Center Area)
                // MOVED UP for better visibility

                // 1. RECRUIT BUTTON (Left)
                const recruitX = 302;
                const recruitY = 560; // Moved up from 620
                const recruitW = 200;
                const recruitH = 60;

                // Draw Recruit Button
                this.ctx.fillStyle = "#2e7d32"; // Green
                this.ctx.fillRect(recruitX, recruitY, recruitW, recruitH);

                // Bevel
                this.ctx.fillStyle = "#4caf50";
                this.ctx.fillRect(recruitX, recruitY, recruitW, 4);
                this.ctx.fillStyle = "#1b5e20";
                this.ctx.fillRect(recruitX, recruitY + recruitH - 4, recruitW, 4);

                this.ctx.fillStyle = "#fff";
                this.ctx.textAlign = "center";
                this.ctx.font = "bold 20px 'MedievalSharp', cursive";
                // Show "HIRED" if already in guild
                const recruitText = (hero && hero.isGuildMember) ? "HIRED" : "HIRE (100 G)";
                this.ctx.fillText(recruitText, recruitX + recruitW / 2, recruitY + 38);

                // 2. DISMISS BUTTON (Right)
                const dismissX = 522;
                const dismissY = 560; // Moved up from 620
                const dismissW = 200;
                const dismissH = 60;

                // Check if we can dismiss (Must have quests?)
                const canDismiss = gameState.quests && gameState.quests.length > 0;

                if (canDismiss) {
                    this.ctx.fillStyle = "#546e7a"; // Stone Blue
                } else {
                    this.ctx.fillStyle = "#37474f"; // Dark/Disabled
                }
                this.ctx.fillRect(dismissX, dismissY, dismissW, dismissH);

                if (canDismiss) {
                    this.ctx.fillStyle = "#78909c";
                    this.ctx.fillRect(dismissX, dismissY, dismissW, 4);
                    this.ctx.fillStyle = "#37474f";
                    this.ctx.fillRect(dismissX, dismissY + dismissH - 4, dismissW, 4);
                    this.ctx.fillStyle = "#eceff1";
                } else {
                    this.ctx.fillStyle = "#546e7a"; // Dim Text
                }

                this.ctx.font = "bold 22px 'MedievalSharp', cursive";
                this.ctx.fillText("DISMISS", dismissX + dismissW / 2, dismissY + 38);




                // Draw Dragged Item (Floating on top)
                if (gameState.dragState) {
                    this.drawDraggedQuest(gameState.dragState);
                }

                // Draw Report Overlay
                if (gameState.report) {
                    this.drawReportCard(gameState.report);
                }

                // Draw Inspection Overlay (if active)
                if (gameState.inspectionData) {
                    this.drawInspectionWindow(gameState.inspectionData);
                }

                // Draw STAMP Animation
                if (gameState.stamp) {
                    this.drawStamp(gameState.stamp);
                }

                // DEBUG OVERLAYS (User Request)
                this.drawDebugOverlays(gameState);
            }

            drawStamp(stamp) {
                // Animate value
                if (stamp.val < 1) stamp.val += 0.08;
                const scale = 2.5 - Math.min(1.0, stamp.val) * 1.5; // 2.5 -> 1.0 big slam
                const alpha = Math.min(1, stamp.val * 3);

                this.ctx.save();
                this.ctx.translate(this.width / 2, this.height / 2);
                this.ctx.scale(scale, scale);
                this.ctx.rotate((Math.random() - 0.5) * 0.2); // Organic rotation

                this.ctx.globalAlpha = alpha;

                // 1. WAX BLOB (Organic Shape)
                let color = "#2f2f2f";
                if (stamp.type === 'ASSIGNED') color = "#8b0000"; // Red
                else if (stamp.type === 'HIRED') color = "#2e7d32"; // Green

                this.ctx.fillStyle = color;

                this.ctx.beginPath();
                // Draw a wobbly circle
                for (let i = 0; i <= Math.PI * 2; i += 0.2) {
                    let r = 100 + Math.random() * 10 - 5;
                    this.ctx.lineTo(Math.cos(i) * r, Math.sin(i) * r);
                }
                this.ctx.closePath();
                this.ctx.fill();

                // Inner rim hint
                this.ctx.strokeStyle = "rgba(0,0,0,0.2)";
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                // 2. EMBOSSED SIGIL (Sword/Shield or X)
                this.ctx.fillStyle = "rgba(0,0,0,0.3)"; // Embossed shadow look

                if (stamp.type === 'ASSIGNED') {
                    // Draw Shield Crest
                    this.ctx.beginPath();
                    this.ctx.moveTo(-40, -50);
                    this.ctx.lineTo(40, -50);
                    this.ctx.lineTo(40, 10);
                    this.ctx.quadraticCurveTo(0, 60, -40, 10);
                    this.ctx.closePath();
                    this.ctx.fill();

                    // Sword line
                    this.ctx.fillStyle = "rgba(0,0,0,0.4)";
                    this.ctx.fillRect(-5, -70, 10, 120);
                    this.ctx.fillRect(-20, -40, 40, 10); // Hilt
                    this.ctx.fillRect(-5, -70, 10, 120);
                    this.ctx.fillRect(-20, -40, 40, 10); // Hilt
                } else if (stamp.type === 'HIRED') {
                    // Draw Checkmark / H
                    this.ctx.fillStyle = "rgba(0,0,0,0.3)";
                    this.ctx.font = "bold 80px 'MedievalSharp', cursive";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("HIRED", 0, 25);
                } else {
                    // Draw "X" or "Dismiss Hand"
                    this.ctx.beginPath();
                    this.ctx.moveTo(-50, -50);
                    this.ctx.lineTo(50, 50);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.moveTo(50, -50);
                    this.ctx.lineTo(-50, 50);
                    this.ctx.stroke();
                }

                // 3. TEXT on the Rim (Small, Medieval)
                // this.ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
                // this.ctx.font = "bold 16px MedievalSharp";
                // this.ctx.textAlign = "center";
                // this.ctx.fillText(stamp.type, 0, 80); 

                this.ctx.restore();
            }

            drawDebugOverlays(gameState) {
                if (gameState.screen !== 'GAME') return;

                this.ctx.save();
                this.ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
                this.ctx.lineWidth = 2;
                this.ctx.font = "12px monospace";
                this.ctx.fillStyle = "red";

                const drawBox = (x, y, w, h, label) => {
                    this.ctx.strokeRect(x, y, w, h);
                    this.ctx.fillText(label, x + 5, y + 15);
                };

                // 1. Roster Button
                drawBox(10, 95, 180, 50, "ROSTER");

                // 2. End Day
                drawBox(860, 30, 130, 50, "END DAY");

                // 3. Recruit (Hitbox)
                drawBox(302, 560, 200, 60, "RECRUIT");

                // 4. Dismiss (Hitbox)
                drawBox(522, 560, 200, 60, "DISMISS");

                // 5. Inspection (Center)
                const cx = this.width / 2;
                // Visual Center calculated: h/2 - 100
                const inspectCy = this.height / 2 - 100;
                drawBox(cx - 120, inspectCy - 120, 240, 240, "INSPECT (R-CLICK)");

                // 6. Quest Drop Zone (Input System Logic)
                // Center calculated: h/2 - 100
                this.ctx.strokeStyle = "cyan";
                this.ctx.fillStyle = "cyan";
                // Input: hitX = cx - 120, hitY = cy - 120, w=240, h=240
                drawBox(cx - 120, inspectCy - 120, 240, 240, "DROP ZONE");

                this.ctx.restore();
            }

            drawInspectionWindow(data) {
                const x = 50;
                const y = 200;
                const w = 300;
                const h = 400;

                // Panel
                this.ctx.fillStyle = "rgba(0, 20, 40, 0.9)";
                this.ctx.fillRect(x, y, w, h);
                this.ctx.strokeStyle = "cyan";
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, w, h);

                // Header
                this.ctx.fillStyle = "cyan";
                this.ctx.font = "bold 18px monospace";
                this.ctx.textAlign = "left";
                this.ctx.fillText("INSPECTION SCANNER", x + 15, y + 30);
                this.ctx.fillRect(x + 15, y + 40, w - 30, 2);

                // Name
                this.ctx.fillStyle = "white";
                this.ctx.font = "bold 16px monospace";
                this.ctx.fillText(data.name, x + 15, y + 70);

                // Details (with wrapping)
                this.ctx.font = "14px monospace";
                this.ctx.fillStyle = "#aaa";

                let ly = y + 100;
                const maxDetailWidth = w - 30;
                const maxY = y + h - 20; // Prevent overflow
                data.details.forEach(detail => {
                    if (ly >= maxY) return; // Stop if we're out of space
                    const prefix = '> ';
                    const words = detail.split(' ');
                    let line = prefix;
                    words.forEach(word => {
                        const testLine = line + word + ' ';
                        if (this.ctx.measureText(testLine).width > maxDetailWidth) {
                            if (ly < maxY) {
                                this.ctx.fillText(line, x + 15, ly);
                                ly += 20;
                            }
                            line = '  ' + word + ' '; // Indent continuation
                        } else {
                            line = testLine;
                        }
                    });
                    if (ly < maxY) {
                        this.ctx.fillText(line, x + 15, ly);
                        ly += 25;
                    }
                });
            }

            drawReportCard(report) {
                // Dim bg
                this.ctx.fillStyle = "rgba(0,0,0,0.7)";
                this.ctx.fillRect(0, 0, this.width, this.height);

                const cx = this.width / 2;
                const cy = this.height / 2;
                const w = 400;
                const h = 300;

                // Card body
                this.ctx.fillStyle = "#fff";
                this.ctx.fillRect(cx - w / 2, cy - h / 2, w, h);
                this.ctx.strokeStyle = "#444";
                this.ctx.lineWidth = 4;
                this.ctx.strokeRect(cx - w / 2, cy - h / 2, w, h);

                // Header
                this.ctx.fillStyle = report.result === "SUCCESS" ? "green" : (report.result === "FAILURE" ? "red" : "orange");
                this.ctx.font = "bold 30px monospace";
                this.ctx.textAlign = "center";
                this.ctx.fillText(report.result, cx, cy - 80);

                // Title
                this.ctx.fillStyle = "#222";
                this.ctx.font = "bold 18px monospace";
                this.ctx.fillText(report.questTitle, cx, cy - 40);

                // Body
                this.ctx.font = "14px monospace";
                this.ctx.fillStyle = "#555";

                // Text wrapping logic (simple)
                const words = report.flavorText.split(' ');
                let line = '';
                let ly = cy + 10;
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = this.ctx.measureText(testLine);
                    if (metrics.width > w - 40 && n > 0) {
                        this.ctx.fillText(line, cx, ly);
                        line = words[n] + ' ';
                        ly += 20;
                    } else {
                        line = testLine;
                    }
                }
                this.ctx.fillText(line, cx, ly);

                // Button Prompt
                this.ctx.fillStyle = "#888";
                this.ctx.font = "12px monospace";
                this.ctx.fillText("[Click to Continue]", cx, cy + 120);
            }

            drawDraggedQuest(dragState) {
                const x = dragState.x;
                const y = dragState.y;
                const paperW = 240; // MUCH LARGER
                const paperH = 300;

                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(-0.05);

                // Shadow
                this.ctx.shadowColor = "rgba(0,0,0,0.6)";
                this.ctx.shadowBlur = 20;
                this.ctx.shadowOffsetY = 20;

                // Paper
                this.ctx.fillStyle = "#f0e6d2";
                this.ctx.fillRect(-paperW / 2, -paperH / 2, paperW, paperH);

                // Border
                this.ctx.strokeStyle = "#5d4037";
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(-paperW / 2, -paperH / 2, paperW, paperH);

                // Title
                this.ctx.fillStyle = "#3e2723";
                this.ctx.font = "bold 20px 'MedievalSharp', cursive";
                this.ctx.textAlign = "center";
                this.ctx.fillText(dragState.item.title, 0, -paperH / 2 + 35);

                // Rank
                this.ctx.fillStyle = "#b71c1c";
                this.ctx.font = "bold 32px monospace";
                this.ctx.fillText("RANK: " + dragState.item.rank, 0, -paperH / 2 + 70);

                // Description
                this.ctx.fillStyle = "#3e2723";
                this.ctx.font = "14px monospace";
                this.ctx.textAlign = "left";

                const words = (dragState.item.desc || "").split(' ');
                let line = '';
                let ly = -paperH / 2 + 110;
                const startX = -paperW / 2 + 15;
                const maxWidth = paperW - 30;

                words.forEach(word => {
                    const testLine = line + word + ' ';
                    if (this.ctx.measureText(testLine).width > maxWidth) {
                        this.ctx.fillText(line, startX, ly);
                        line = word + ' ';
                        ly += 20;
                    } else {
                        line = testLine;
                    }
                });
                this.ctx.fillText(line, startX, ly);

                // Tags (with wrapping)
                ly += 30;
                this.ctx.font = "bold 12px monospace";
                this.ctx.fillStyle = "#5d4037";
                this.ctx.fillText("Tags:", startX, ly);
                ly += 18;
                this.ctx.font = "italic 11px monospace";
                if (dragState.item.tags) {
                    const tagText = dragState.item.tags.join(", ");
                    let tagLine = '';
                    const tagWords = tagText.split(', ');
                    tagWords.forEach((tag, idx) => {
                        const testLine = tagLine + (tagLine ? ', ' : '') + tag;
                        if (this.ctx.measureText(testLine).width > maxWidth) {
                            this.ctx.fillText(tagLine, startX, ly);
                            ly += 16;
                            tagLine = tag;
                        } else {
                            tagLine = testLine;
                        }
                    });
                    if (tagLine) this.ctx.fillText(tagLine, startX, ly);
                }

                this.ctx.restore();
            }

            getPortrait(hero) {
                if (!hero.race || !hero.classId) return null;

                // Smart portrait mapping based on available files:
                // dwarf_paladin, elf_mage, elf_ranger, human_cleric, human_necromancer, 
                // human_rogue, human_warrior, orc_barbarian, orc_barbarian_rusty

                let portraitKey = null;

                // 1. Direct map first
                const directKey = `${hero.race}_${hero.classId}`;

                // 2. Fallback mapping based on class type
                if (hero.race === 'human') {
                    if (['warrior', 'pit_fighter', 'mercenary', 'ronin', 'guard'].includes(hero.classId)) {
                        portraitKey = 'human_warrior';
                    } else if (hero.classId === 'knight') {
                        portraitKey = 'human_knight';
                    } else if (['rogue', 'spy', 'treasure_hunter'].includes(hero.classId)) {
                        portraitKey = 'human_rogue';
                    } else if (['assassin'].includes(hero.classId)) {
                        portraitKey = 'human_rogue';
                    } else if (['bard'].includes(hero.classId)) {
                        portraitKey = 'human_rogue';
                    } else if (['cleric'].includes(hero.classId)) {
                        portraitKey = 'human_cleric';
                    } else if (['monk'].includes(hero.classId)) {
                        portraitKey = 'human_cleric';
                    } else if (['necromancer', 'cultist'].includes(hero.classId)) {
                        portraitKey = 'human_necromancer';
                    }
                }

                if (hero.race === 'elf') {
                    if (['battle_mage', 'scholar', 'illusionist', 'elementalist', 'hedge_wizard'].includes(hero.classId)) {
                        portraitKey = 'elf_mage';
                    } else if (['ranger', 'druid'].includes(hero.classId)) {
                        portraitKey = 'elf_ranger';
                    }
                }

                if (hero.race === 'orc' && hero.classId === 'barbarian') {
                    // Check for rusty variant
                    if (hero.visuals && hero.visuals.includes('rusty_gear')) {
                        portraitKey = 'orc_barbarian_rusty';
                    } else {
                        portraitKey = 'orc_barbarian';
                    }
                }

                if (hero.race === 'dwarf' && hero.classId === 'paladin') {
                    portraitKey = 'dwarf_paladin';
                }

                if (!portraitKey) return null;

                // Return cached or create new
                if (!this.portraits[portraitKey]) {
                    const img = new Image();
                    img.src = `assets/portraits/${portraitKey}.png`;
                    this.portraits[portraitKey] = img;
                }

                return this.portraits[portraitKey];
            }

            drawAdventurerPlaceholder(hero) {
                const cx = this.width / 2;
                const cy = this.height / 2 - 50;

                // Try to load portrait sprite
                const portrait = this.getPortrait(hero);

                if (portrait && portrait.complete && portrait.naturalWidth > 0) {
                    // SPRITE-BASED RENDERING
                    const size = 240; // Portrait size (increased from 220 for better presence)

                    // Add subtle shadow/glow behind portrait for depth
                    this.ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 10;

                    // Draw portrait
                    this.ctx.drawImage(
                        portrait,
                        cx - size / 2,
                        cy - size / 2 - 50, // Slightly higher placement
                        size,
                        size
                    );

                    // Guild Member Badge (Top Left of Portrait)
                    if (hero.isGuildMember) {
                        const badgeX = cx - size / 2 + 10;
                        const badgeY = cy - size / 2 - 50 + 10; // Relative to portrait top-left

                        // Badge Background
                        this.ctx.fillStyle = "#FFD700"; // Gold
                        this.ctx.strokeStyle = "#fff";
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(badgeX + 15, badgeY + 15, 18, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.stroke();

                        // Badge Text
                        this.ctx.fillStyle = "#000";
                        this.ctx.font = "bold 20px monospace";
                        this.ctx.textAlign = "center";
                        this.ctx.fillText("G", badgeX + 15, badgeY + 22);
                    }

                    // Reset shadow
                    this.ctx.shadowBlur = 0;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 0;

                    // Add subtle visual overlays for special traits
                    if (hero.visuals) {
                        // BANDAGED (White strips overlays)
                        if (hero.visuals.includes("bandaged")) {
                            this.ctx.strokeStyle = "#eee";
                            this.ctx.lineWidth = 4;
                            this.ctx.beginPath();
                            this.ctx.moveTo(cx - 50, cy + 30);
                            this.ctx.lineTo(cx - 20, cy + 40);
                            this.ctx.stroke();
                        }

                        // SHAKING ANIMATION
                        let offsetX = 0;
                        if (hero.visuals.includes("shaking")) {
                            offsetX = (Math.random() - 0.5) * 5; // Jitter
                        }

                        // Name label with strong outline for visibility
                        this.ctx.strokeStyle = "black";
                        this.ctx.lineWidth = 5;
                        this.ctx.font = "bold 20px 'MedievalSharp', monospace";
                        this.ctx.textAlign = "center";
                        this.ctx.strokeText(hero.name, cx + offsetX, cy - 170);

                        this.ctx.fillStyle = "#FFFFFF"; // White text
                        this.ctx.fillText(hero.name, cx + offsetX, cy - 170);
                    }

                } else {
                    // FALLBACK: SILHOUETTE RENDERING (Original code)
                    this.ctx.fillStyle = "rgba(50, 50, 50, 1.0)";

                    if (hero.visuals && hero.visuals.includes("scrawny")) {
                        this.ctx.fillStyle = "rgba(60, 60, 60, 1.0)";
                    }

                    this.ctx.beginPath();
                    let width = 80;
                    if (hero.visuals) {
                        if (hero.visuals.includes("muscles")) width = 100;
                        if (hero.visuals.includes("scrawny")) width = 60;
                    }

                    this.ctx.ellipse(cx, cy + 50, width, 180, 0, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Visual tells
                    if (hero.visuals) {
                        if (hero.visuals.includes("glowing_eyes")) {
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = "cyan";
                            this.ctx.fillStyle = "cyan";
                            this.ctx.beginPath();
                            this.ctx.arc(cx - 20, cy - 80, 5, 0, Math.PI * 2);
                            this.ctx.arc(cx + 20, cy - 80, 5, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.shadowBlur = 0;
                        }

                        if (hero.visuals.includes("jewelry")) {
                            this.ctx.strokeStyle = "gold";
                            this.ctx.lineWidth = 3;
                            this.ctx.beginPath();
                            this.ctx.arc(cx, cy - 30, 40, 0, Math.PI, false);
                            this.ctx.stroke();
                            this.ctx.fillStyle = "red";
                            this.ctx.beginPath();
                            this.ctx.arc(cx, cy + 10, 8, 0, Math.PI * 2);
                            this.ctx.fill();
                        }

                        if (hero.visuals.includes("pristine_armor")) {
                            this.ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                            this.ctx.beginPath();
                            this.ctx.moveTo(cx - 30, cy);
                            this.ctx.lineTo(cx + 30, cy + 20);
                            this.ctx.lineTo(cx - 30, cy + 40);
                            this.ctx.fill();
                        }

                        if (hero.visuals.includes("rusty_gear")) {
                            this.ctx.fillStyle = "#8b4513";
                            this.ctx.fillRect(cx - 40, cy + 20, 10, 10);
                            this.ctx.fillRect(cx + 30, cy + 60, 15, 15);
                        }

                        if (hero.visuals.includes("bandaged")) {
                            this.ctx.strokeStyle = "#eee";
                            this.ctx.lineWidth = 4;
                            this.ctx.beginPath();
                            this.ctx.moveTo(cx - 50, cy + 50);
                            this.ctx.lineTo(cx - 20, cy + 60);
                            this.ctx.stroke();
                            this.ctx.beginPath();
                            this.ctx.moveTo(cx + 20, cy - 100);
                            this.ctx.lineTo(cx + 50, cy - 90);
                            this.ctx.stroke();
                        }
                    }

                    // Name
                    let offsetX = 0;
                    if (hero.visuals && hero.visuals.includes("shaking")) {
                        offsetX = (Math.random() - 0.5) * 5;
                    }

                    this.ctx.fillStyle = "#ffffff";
                    this.ctx.font = "bold 20px 'MedievalSharp', monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.shadowColor = "black";
                    this.ctx.shadowBlur = 4;
                    this.ctx.fillText(hero.name, cx + offsetX, cy - 150);
                    this.ctx.shadowBlur = 0;

                    // Question mark
                    this.ctx.fillStyle = "#FFD700";
                    this.ctx.font = "bold 48px monospace";
                    this.ctx.fillText("?", cx, cy + 60);
                }
            }

            drawQuestBoard(quests) {
                if (!quests || quests.length === 0) return;

                // Board Area (Calculated)
                const startX = 640;
                const startY = 220;
                const paperW = 100;
                const paperH = 130;
                const gap = 15;
                const cols = 3;

                this.ctx.save();
                this.ctx.shadowColor = "rgba(0,0,0,0.5)";
                this.ctx.shadowBlur = 2;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 2;

                quests.forEach((quest, index) => {
                    // Skip if currently being dragged (implied by Input logic, need to check logic)
                    if (gameState.dragState && gameState.dragState.item === quest) return;

                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    const x = startX + col * (paperW + gap);
                    const y = startY + row * (paperH + gap) + (index % 2 * 5); // Slight stagger

                    // Paper Background
                    this.ctx.fillStyle = "#f0e6d2"; // Parchment
                    this.ctx.fillRect(x, y, paperW, paperH);

                    // Title (readable)
                    this.ctx.fillStyle = "#3e2723";
                    this.ctx.font = "bold 11px monospace";
                    this.ctx.textAlign = "center";
                    const words = quest.title.split(' ');
                    if (words.length > 2) {
                        this.ctx.fillText(words.slice(0, 2).join(' '), x + paperW / 2, y + 25);
                        this.ctx.fillText(words.slice(2).join(' '), x + paperW / 2, y + 40);
                    } else {
                        this.ctx.fillText(quest.title, x + paperW / 2, y + 30);
                    }

                    // Rank Label (Large)
                    this.ctx.fillStyle = "#b71c1c";
                    this.ctx.font = "bold 32px monospace";
                    this.ctx.fillText(quest.rank, x + paperW / 2, y + paperH / 2 + 20);

                    // Seal at bottom
                    this.ctx.fillStyle = (quest.rank === 'S' || quest.rank === 'A') ? "#8b0000" : "#4a3728";
                    this.ctx.beginPath();
                    this.ctx.arc(x + paperW / 2, y + paperH - 20, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.restore();
            }
        }

        // 5. MAIN LOOP
        const canvas = document.getElementById('game-canvas');
        canvas.width = 1024;
        canvas.height = 768;
        const renderer = new Renderer(canvas);

        let gameState = {
            screen: 'START', // START, GAME, REPORT
            day: 1,
            currentAdventurer: null,
            pendingReports: [] // Stores results from the day
        };

        function startGame() {
            gameState.screen = 'GAME';
            startNewDay();
        }

        function startNewDay() {
            gameState.day++;
            gameState.pendingReports = []; // Clear previous day's reports

            // RESET DAILY ASSIGNMENTS (User Fix)
            if (gameState.persistence) {
                gameState.persistence.resetDailyState();
            }

            // Generate Adventurer
            gameState.currentAdventurer = AdventurerGenerator.generate(gameState.day);

            // Load Quests (from Data Layer)
            if (window.GameData && window.GameData.Quests) {
                // Shuffle and pick 3-6
                const count = Math.floor(Math.random() * 4) + 3;
                gameState.quests = [...window.GameData.Quests].sort(() => 0.5 - Math.random()).slice(0, count);
            } else {
                console.warn("Quests not loaded!");
                gameState.quests = [];
            }
        }

        async function init() {
            document.getElementById('debug-console').style.display = 'none';
            await renderer.loadAssets();

            // Initialize Systems
            gameState.economy = new window.GameSystems.EconomyManager(50);
            gameState.inspector = new window.GameSystems.Inspector();
            gameState.persistence = new window.GameSystems.PersistenceManager(); // NEW
            const input = new window.GameSystems.InputController(canvas, gameState);

            // Event: Next Adventurer (Same Day)
            document.addEventListener('nextAdventurer', () => {
                // Chance to return old adventurer?
                let returningParams = null;
                // 30% chance if we have history
                if (gameState.persistence && Math.random() < 0.3) {
                    returningParams = gameState.persistence.getReturningAdventurer();
                }

                if (returningParams) {
                    console.log("RETURNING HERO:", returningParams.name);
                    gameState.currentAdventurer = new window.GameSystems.Adventurer(returningParams);
                    // Force refresh visuals in case traits changed
                    // (Constructor calls generateVisuals, so it should be fine if traits are passed correctly)
                } else {
                    gameState.currentAdventurer = AdventurerGenerator.generate(gameState.day);
                }
            });

            // Event: Manual End Day
            document.addEventListener('endDayManual', () => {
                // Process Upkeep
                const upkeep = gameState.economy.processDailyUpkeep();
                gameState.lastUpkeep = upkeep; // Store for report display
                if (upkeep.bankrupt) {
                    alert("GAME OVER: You ran out of gold!");
                    location.reload();
                    return;
                }

                gameState.screen = 'REPORT';
                gameState.reportOpenedAt = Date.now(); // Prevent immediate click-through
            });

            // Event: Recruit Adventurer (Manual)
            document.addEventListener('recruitAdventurer', () => {
                console.log("Event: recruitAdventurer triggered");

                const hero = gameState.currentAdventurer;
                if (!hero) {
                    console.error("No adventurer to recruit!");
                    return;
                }

                if (hero.isGuildMember) {
                    console.log("Already a member");
                    return;
                }

                // Direct Gold Deduction (Safer)
                gameState.economy.gold -= 100;

                // Recruit THIS adventurer
                hero.isGuildMember = true;
                console.log("Recruited:", hero.name);

                // Visual Feedback
                gameState.stamp = { type: 'HIRED', val: 0 };

                // Clear stamp after 800ms (same as Assigned)
                setTimeout(() => {
                    if (gameState.stamp && gameState.stamp.type === 'HIRED') {
                        gameState.stamp = null;
                    }
                }, 800);

                if (gameState.persistence) {
                    gameState.persistence.addToRoster(hero);
                }
            });

            // Event: Toggle Roster
            document.addEventListener('toggleRoster', () => {
                if (gameState.screen === 'GAME') {
                    gameState.screen = 'ROSTER';
                    gameState.rosterOpenedAt = Date.now(); // Prevent immediate closing
                } else if (gameState.screen === 'ROSTER') {
                    gameState.screen = 'GAME';
                }
            });

            // Input (Keyboard still useful for debug/start)
            window.addEventListener('keydown', (e) => {
                if (gameState.screen === 'START') {
                    if (e.code === 'Space' || e.code === 'Enter') startGame();
                } else if (gameState.screen === 'GAME') {
                    // if (e.code === 'Space') startNewDay(); // Disable space to skip
                } else if (gameState.screen === 'ROSTER') {
                    if (e.code === 'Escape' || e.code === 'Space') gameState.screen = 'GAME';
                } else if (gameState.screen === 'REPORT') {
                    if (e.code === 'Space') {
                        // Collect gold from completed quests
                        if (gameState.pendingReports && gameState.pendingReports.length > 0) {
                            let totalGold = 0;
                            gameState.pendingReports.forEach(report => {
                                totalGold += report.goldEarned || 0;
                            });
                            if (totalGold > 0 && gameState.economy) {
                                gameState.economy.addGold(totalGold);
                                console.log(`Day complete! Earned ${totalGold} gold from ${gameState.pendingReports.length} quests`);
                            }
                        }

                        gameState.screen = 'GAME';
                        startNewDay();
                    }
                }
            });

            // Mouse Click for Start and Report
            canvas.addEventListener('click', (e) => { // Captured e
                if (gameState.screen === 'START') startGame();
                else if (gameState.screen === 'ROSTER') {
                    if (gameState.rosterOpenedAt && Date.now() - gameState.rosterOpenedAt < 300) return;

                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;

                    // A. DETAIL VIEW OPEN
                    if (gameState.rosterDetailMember) {
                        const w = 600;
                        const h = 550;
                        const modalX = (canvas.width - w) / 2;
                        const modalY = (canvas.height - h) / 2;
                        const btnY = modalY + h - 80;

                        // 1. CLOSE (Top Right X)
                        if (x >= modalX + w - 40 && x <= modalX + w && y >= modalY && y <= modalY + 40) {
                            gameState.rosterDetailMember = null;
                            return;
                        }

                        // 2. HEAL (Left Button)
                        if (gameState.rosterDetailMember.injuries && gameState.rosterDetailMember.injuries.length > 0) {
                            if (x >= modalX + 40 && x <= modalX + 200 && y >= btnY && y <= btnY + 50) {
                                if (gameState.economy.gold >= 50) {
                                    gameState.economy.gold -= 50;
                                    gameState.rosterDetailMember.injuries = []; // CURED
                                    gameState.rosterDetailMember.traits = gameState.rosterDetailMember.traits.filter(t => t !== 'Injured');
                                    alert(`${gameState.rosterDetailMember.name} has been treated!`);
                                    gameState.persistence.saveAdventurer(gameState.rosterDetailMember, { result: "TREATED", questTitle: "Infirmary" }); // Save state
                                } else {
                                    alert("Not enough gold to treat injury (50G).");
                                }
                                return;
                            }
                        }

                        // 3. FIRE (Right Button)
                        if (x >= modalX + w - 180 && x <= modalX + w - 40 && y >= btnY && y <= btnY + 50) {
                            if (confirm(`Are you sure you want to fire ${gameState.rosterDetailMember.name}?`)) {
                                gameState.persistence.roster.delete(gameState.rosterDetailMember.id);
                                gameState.rosterDetailMember = null;
                            }
                            return;
                        }

                        return; // Modal consumes clicks
                    }

                    // B. LIST VIEW
                    // Check rows. Y starts 180, height 40 per row approx
                    const members = gameState.persistence ? Array.from(gameState.persistence.roster.values()) : [];
                    let rowY = 180;
                    for (let m of members) {
                        if (y >= rowY - 25 && y <= rowY + 10) { // Approx hit area based on text drawing
                            gameState.rosterDetailMember = m;
                            return;
                        }
                        rowY += 40;
                    }

                    // Click outside -> Close Roster
                    gameState.screen = 'GAME';
                }
                else if (gameState.screen === 'REPORT') {
                    // Prevent click-through: require 300ms delay after report opens
                    if (gameState.reportOpenedAt && Date.now() - gameState.reportOpenedAt < 300) {
                        return; // Ignore click
                    }

                    // Collect gold from completed quests
                    if (gameState.pendingReports && gameState.pendingReports.length > 0) {
                        let totalGold = 0;
                        gameState.pendingReports.forEach(report => {
                            totalGold += report.goldEarned || 0;
                        });
                        if (totalGold > 0 && gameState.economy) {
                            gameState.economy.addGold(totalGold);
                            console.log(`Day complete! Earned ${totalGold} gold from ${gameState.pendingReports.length} quests`);
                        }
                    }

                    gameState.screen = 'GAME';
                    startNewDay();
                }
            });

            gameLoop();
        }

        function gameLoop() {
            renderer.draw(gameState);
            requestAnimationFrame(gameLoop);
        }

        // Start immediately
        init();
    </script>
    <!-- REMOVED script.js import -->
</body>

</html>