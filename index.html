<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Guild Master - Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">

    <!-- ALL EXISTING SYSTEMS -->
    <script src="js/data/traitData.js"></script>
    <script src="js/data/questData.js"></script>
    <script src="js/data/visitorData.js"></script>
    <script src="js/models/Adventurer.js"></script>
    <script src="js/models/VisualTraits.js"></script>
    <script src="js/systems/Inspector.js"></script>
    <script src="js/systems/Persistence.js"></script>
    <script src="js/systems/Economy.js"></script>
    <script src="js/systems/Input.js"></script>
    <script src="js/systems/CrownChecker.js"></script>
    <script src="js/systems/Resolution.js"></script>
    <script src="js/systems/Events.js"></script>
    <script src="js/systems/Town.js"></script>
    <script src="js/systems/CrownSystem.js"></script>
    <script src="js/systems/Visitor.js"></script>
    <script src="src/data/adventurerData.js"></script>
    <script src="src/generators/adventurerGenerator.js"></script>

    <link rel="stylesheet" href="css/mobile.css">
    <link rel="stylesheet" href="css/report-styles.css">
</head>

<body>

    <!-- MOBILE APP CONTAINER -->
    <div id="mobile-game">

        <!-- START SCREEN -->
        <div id="screen-start" class="screen">
            <div class="start-content">
                <h1 class="game-title">GUILD MASTER</h1>
                <button id="btn-start" class="btn-large btn-gold">START GAME</button>
            </div>
        </div>

        <!-- GAME SCREEN (Main Gameplay) -->
        <div id="screen-game" class="screen hidden">
            <!-- Header -->
            <header id="game-header">
                <button id="btn-roster-toggle" class="header-btn">üìã ROSTER</button>
                <button id="btn-crown-status" class="header-btn crown-btn">üëë</button>
                <span id="crown-rep-display" style="color: #aaa; font-size: 0.85em; margin: 0 10px;">Crown:
                    Neutral</span>
                <div id="gold-display" class="gold-display">
                    üí∞ <span id="gold-value">100</span> G
                </div>
            </header>

            <!-- Main Stage -->
            <main id="game-main">
                <!-- Queue Indicator -->
                <div class="queue-indicator">
                    Visitor <span id="queue-current">1</span> of <span id="queue-total">1</span>
                </div>

                <!-- Character Card -->
                <div class="char-card">
                    <div class="char-portrait-wrapper">
                        <img id="char-portrait" class="char-portrait" src="assets/counter_view.png" alt="Adventurer">
                    </div>
                    <div class="char-info-panel">
                        <h2 id="char-name" class="char-name">Loading...</h2>
                        <p id="char-subtitle" class="char-subtitle">-</p>
                        <div id="char-traits" class="char-traits"></div>
                        <blockquote id="char-quote" class="char-quote">"..."</blockquote>
                    </div>
                </div>

                <!-- Quest Board -->
                <section id="quest-board-section">
                    <h3 class="section-header">AVAILABLE CONTRACTS</h3>
                    <div id="quest-board" class="quest-board"></div>
                </section>
            </main>

            <!-- Footer Actions -->
            <footer id="game-footer">
                <button id="btn-end-day" class="btn-action btn-red">END DAY</button>
                <div class="decision-row">
                    <button id="btn-hire" class="btn-decision btn-green">HIRE (100 G)</button>
                    <button id="btn-dismiss" class="btn-decision btn-grey">DISMISS</button>
                </div>
            </footer>
        </div>

        <!-- REPORT SCREEN (End of Day) -->
        <div id="screen-report" class="screen hidden">
            <div class="report-parchment">
                <h2 id="report-title" class="report-title">Guild Daily Ledger</h2>
                <p id="report-day" class="report-day">Day 1</p>
                <div id="report-content" class="report-content"></div>
                <div id="report-summary" class="report-summary"></div>
                <button id="btn-next-day" class="btn-large btn-red">NEXT DAY</button>
            </div>
        </div>

        <!-- ROSTER SCREEN -->
        <div id="screen-roster" class="screen hidden">
            <div class="roster-container">
                <h2 class="roster-title">Guild Roster</h2>
                <div id="roster-list" class="roster-list"></div>
                <button id="btn-close-roster" class="btn-large btn-grey">BACK TO DESK</button>
            </div>
        </div>

        <!-- CROWN EVENT SCREEN -->
        <div id="screen-crown-event" class="screen hidden">
            <div class="crown-modal">
                <h2 id="crown-event-title">Royal Messenger</h2>
                <p id="crown-event-text"></p>
                <button id="btn-acknowledge-crown" class="btn-large btn-gold">ACKNOWLEDGE</button>
            </div>
        </div>

        <!-- CHARACTER INSPECTOR MODAL -->
        <div id="inspector-modal" class="screen hidden">
            <div class="crown-modal">
                <h2 id="inspector-title">Character Details</h2>
                <pre id="inspector-content"
                    style="font-family: 'MedievalSharp', monospace; white-space: pre-wrap; text-align: left; line-height: 1.6;"></pre>
                <button id="btn-close-inspector" class="btn-large btn-grey">CLOSE</button>
            </div>
        </div>

        <!-- VISITOR MODAL -->
        <div id="visitor-modal" class="screen hidden">
            <div class="crown-modal" style="max-width: 500px;">
                <h2 id="visitor-title">Visitor</h2>
                <p id="visitor-dialogue" style="white-space: pre-wrap; line-height: 1.6; margin: 20px 0;"></p>
                <div id="visitor-choices" class="decision-row" style="flex-direction: column; gap: 10px;"></div>
            </div>
        </div>

        <!-- QUEST DETAILS MODAL -->
        <div id="quest-details-modal" class="screen hidden">
            <div class="crown-modal" style="max-width: 550px;">
                <h2 id="quest-detail-title">Quest Name</h2>
                <p id="quest-detail-desc" style="margin: 15px 0; line-height: 1.6;"></p>
                <p id="quest-detail-hazard" style="color: #ff6b6b; margin: 10px 0; font-weight: bold;"></p>
                <p id="quest-detail-meta" style="color: #888; font-size: 0.9em; margin: 10px 0;"></p>
                <button id="btn-close-quest-details" class="btn-large btn-grey">CLOSE</button>
            </div>
        </div>


        <!-- GAME LOGIC (Inline - matching Canvas version structure) -->
        <script>
            // Game State (matching Canvas version)
            const gameState = {
                screen: 'START',
                day: 0,
                currentAdventurer: null,
                quests: [],
                pendingReports: [],
                stamp: null,
                crown: { nextVisitDay: 3, activeQuest: null, history: [] },
                crownEvent: null,
                crownStatusOpen: false,
                dailyEvent: null,
                lastUpkeep: null,
                reportOpenedAt: null,
                rosterOpenedAt: null,
                // Systems (initialized in init())
                economy: null,
                inspector: null,
                persistence: null,
                events: null,
                town: null,
                crownSystem: null,
                visitor: null,
                // Reputation tracking
                crownReputation: 0,
                townReputation: 0
            };

            // IMPORTANT: Expose to window so Town.js can access guild members
            window.gameState = gameState;

            // DOM Elements Cache
            const DOM = {
                screens: {
                    start: document.getElementById('screen-start'),
                    game: document.getElementById('screen-game'),
                    report: document.getElementById('screen-report'),
                    roster: document.getElementById('screen-roster'),
                    crownEvent: document.getElementById('screen-crown-event')
                },
                goldValue: document.getElementById('gold-value'),
                charPortrait: document.getElementById('char-portrait'),
                charName: document.getElementById('char-name'),
                charSubtitle: document.getElementById('char-subtitle'),
                charTraits: document.getElementById('char-traits'),
                charQuote: document.getElementById('char-quote'),
                questBoard: document.getElementById('quest-board'),
                reportContent: document.getElementById('report-content'),
                reportSummary: document.getElementById('report-summary'),
                rosterList: document.getElementById('roster-list')
            };

            // Drag-and-Drop State
            let draggedQuest = null;

            // ================================================
            // RENDERING FUNCTIONS
            // ================================================

            function setScreen(screenName) {
                Object.keys(DOM.screens).forEach(key => {
                    DOM.screens[key].classList.add('hidden');
                });
                if (DOM.screens[screenName]) {
                    DOM.screens[screenName].classList.remove('hidden');
                }
                gameState.screen = screenName.toUpperCase();
            }

            function updateGoldDisplay() {
                DOM.goldValue.textContent = gameState.economy ? gameState.economy.gold : 0;
            }

            function updateReputationDisplay() {
                const repDisplay = document.getElementById('crown-rep-display');
                if (!repDisplay) return;

                const rep = gameState.crownReputation || 0;
                let label, color;

                if (rep >= 5) {
                    label = "Favored";
                    color = "#ffd700"; // Gold
                } else if (rep <= -5) {
                    label = "Disfavored";
                    color = "#ff6b6b"; // Red
                } else {
                    label = "Neutral";
                    color = "#aaa"; // Gray
                }

                repDisplay.textContent = `Crown: ${label} (${rep >= 0 ? '+' : ''}${rep})`;
                repDisplay.style.color = color;
            }

            function renderCharacter() {
                const char = gameState.currentAdventurer;

                // Update queue indicator
                const queueRemaining = gameState.town ? gameState.town.dailyQueue.length : 0;
                const queueTotal = queueRemaining + (char ? 1 : 0);
                const queueCurrent = queueTotal - queueRemaining;
                document.getElementById('queue-current').textContent = char ? queueCurrent : 0;
                document.getElementById('queue-total').textContent = queueTotal;

                if (!char) {
                    // Show Guild Assistant instead of empty desk
                    DOM.charName.textContent = "Sera";
                    DOM.charSubtitle.textContent = "Guild Inn-keeper";
                    DOM.charTraits.innerHTML = '';

                    // Friendly dialogue variations
                    const seraSayings = [
                        "All visitors seen for today, Guild Master. Rest well earned!",
                        "The day's business concludes, Master. Shall I prepare the evening reports?",
                        "Quiet at the guild tonight. A good sign, perhaps?",
                        "No more adventurers today, Master. Time to count our coin!",
                        "The queue is empty, Guild Master. Your efficiency is admirable~",
                        "That's everyone for today! Shall I fetch you some ale while you tally the books?"
                    ];
                    const seraSaying = seraSayings[Math.floor(Math.random() * seraSayings.length)];
                    DOM.charQuote.textContent = `"${seraSaying}"`;

                    // Use female elf ranger portrait as placeholder for inn-keeper
                    DOM.charPortrait.src = 'assets/portraits/elf_ranger_female_1.png';
                    DOM.charPortrait.onerror = () => {
                        // Fallback to any female portrait
                        DOM.charPortrait.src = 'assets/portraits/human_cleric_female_1.png';
                        DOM.charPortrait.onerror = () => {
                            // Final fallback
                            DOM.charPortrait.src = 'assets/counter_view.png';
                        };
                    };

                    // Remove drop zone listeners
                    DOM.charPortrait.ondragover = null;
                    DOM.charPortrait.ondragleave = null;
                    DOM.charPortrait.ondrop = null;
                    return;
                }

                DOM.charName.textContent = char.name;
                DOM.charSubtitle.textContent = `Level ${char.level || 1} ${char.classId} (${char.race})`;

                // Add guild member badge if applicable
                const existingBadge = document.querySelector('.guild-badge');
                if (existingBadge) existingBadge.remove();

                if (char.isGuildMember) {
                    const badge = document.createElement('div');
                    badge.className = 'guild-badge';
                    badge.innerHTML = 'üõ°Ô∏è GUILD MEMBER';
                    DOM.charSubtitle.insertAdjacentElement('afterend', badge);
                }

                // Portrait - Use visualClass (mapped by generator) instead of classId
                // visualClass maps logical classes (guard, monk, etc.) to asset names (warrior, cleric, etc.)
                const visualClass = char.visualClass || char.classId; // Fallback if old data

                // CRITICAL FIX: Check for SAVED portrait path first!
                if (char.portraitPath) {
                    // Use the saved portrait path (from persistence)
                    console.log(`‚úÖ Using saved portrait for ${char.name}: ${char.portraitPath}`);
                    DOM.charPortrait.src = char.portraitPath;
                } else {
                    // Generate NEW portrait path (first time only)
                    console.log(`üé® Generating NEW portrait for ${char.name} (${visualClass})`);

                    // SIMPLIFIED: Guild members always get variant 1 (no randomness!)
                    // Town visitors can have variants
                    const portraitVariant = char.isGuildMember ? 1 : (Math.floor(Math.random() * 3) + 1);

                    // Gender detection: check if name suggests female
                    const femaleNames = ['lyra', 'elara', 'sera', 'maya', 'aria', 'zara', 'nova', 'mira'];
                    const isFemale = femaleNames.some(name => char.name.toLowerCase().includes(name));

                    // For humans, portraits follow: race_class_gender_variant.png
                    if (char.race === 'human') {
                        const gender = isFemale ? 'female' : 'male';
                        const path1 = `assets/portraits/human_${visualClass}_${gender}_${portraitVariant}.png`;

                        // Set and save immediately
                        char.portraitPath = path1;
                        DOM.charPortrait.src = path1;

                        // Save to persistence for guild members
                        if (char.isGuildMember && gameState.persistence) {
                            const data = gameState.persistence.roster.get(char.id);
                            if (data) {
                                data.portraitPath = path1;
                                console.log(`üíæ Saved portrait to roster for ${char.name}: ${path1}`);
                            }
                        }

                        // Fallback chain
                        DOM.charPortrait.onerror = () => {
                            console.warn(`‚ö†Ô∏è Portrait not found: ${path1}`);
                            // Try without variant
                            const fallback1 = `assets/portraits/human_${visualClass}_${gender}_1.png`;
                            DOM.charPortrait.src = fallback1;

                            DOM.charPortrait.onerror = () => {
                                // Try opposite gender
                                const altGender = gender === 'male' ? 'female' : 'male';
                                const fallback2 = `assets/portraits/human_${visualClass}_${altGender}_1.png`;
                                DOM.charPortrait.src = fallback2;

                                DOM.charPortrait.onerror = () => {
                                    // Final fallback: warrior
                                    DOM.charPortrait.src = `assets/portraits/human_warrior_male_1.png`;
                                };
                            };
                        };
                    } else {
                        // Non-human races: race_class_variant.png
                        const basePath = `assets/portraits/${char.race}_${visualClass}`;
                        // Guild members get variant 1, town visitors get random
                        const variant = char.isGuildMember ? 1 : portraitVariant;
                        const path1 = `${basePath}_${variant}.png`;

                        // Set and save immediately
                        char.portraitPath = path1;
                        DOM.charPortrait.src = path1;

                        // Save to persistence for guild members
                        if (char.isGuildMember && gameState.persistence) {
                            const data = gameState.persistence.roster.get(char.id);
                            if (data) {
                                data.portraitPath = path1;
                                console.log(`üíæ Saved portrait to roster for ${char.name}: ${path1}`);
                            }
                        }

                        DOM.charPortrait.onerror = () => {
                            console.warn(`‚ö†Ô∏è Portrait not found: ${path1}`);
                            // Try variant 1
                            DOM.charPortrait.src = `${basePath}_1.png`;
                            DOM.charPortrait.onerror = () => {
                                // Race-specific fallback
                                const fallbacks = {
                                    elf: 'assets/portraits/elf_ranger_1.png',
                                    dwarf: 'assets/portraits/dwarf_paladin_1.png',
                                    orc: 'assets/portraits/orc_warrior_1.png'
                                };
                                DOM.charPortrait.src = fallbacks[char.race] || 'assets/portraits/human_warrior_male_1.png';
                            };
                        };
                    }
                }

                // Traits
                DOM.charTraits.innerHTML = '';
                if (char.traits && char.traits.length > 0) {
                    char.traits.forEach(trait => {
                        const pill = document.createElement('span');
                        pill.className = 'trait-pill';
                        pill.textContent = trait;
                        DOM.charTraits.appendChild(pill);
                    });
                }

                // Quote (simple for now)
                const quotes = [
                    "I need work.",
                    "Point me to the danger.",
                    "Let's earn some gold.",
                    "I'm ready for this.",
                    "Show me the contract."
                ];
                DOM.charQuote.textContent = `"${quotes[Math.floor(Math.random() * quotes.length)]}"`;

                // Click to inspect character details - CAPTURE char in closure!
                const adventurerToInspect = char; // Capture current char
                DOM.charPortrait.onclick = () => {
                    if (adventurerToInspect && gameState.inspector) {
                        gameState.inspector.show(adventurerToInspect);
                    }
                };
                DOM.charPortrait.style.cursor = 'pointer';

                // Setup Drop Zone for Drag-and-Drop
                DOM.charPortrait.ondragover = (e) => {
                    if (draggedQuest && !char.isAssigned) {
                        e.preventDefault();
                        DOM.charPortrait.classList.add('drag-over');
                    }
                };

                DOM.charPortrait.ondragleave = (e) => {
                    DOM.charPortrait.classList.remove('drag-over');
                };

                DOM.charPortrait.ondrop = (e) => {
                    e.preventDefault();
                    DOM.charPortrait.classList.remove('drag-over');
                    if (draggedQuest && char && !char.isAssigned) {
                        assignQuestToVisitor(draggedQuest.quest, draggedQuest.index);
                    }
                };

                // Show assigned quest if any
                const parent = DOM.charQuote.parentElement;
                // Clear any existing badges
                const oldBadge = parent.querySelector('.assigned-badge');
                if (oldBadge) oldBadge.remove();

                if (char.isAssigned && char.currentQuest !== null && gameState.quests[char.currentQuest]) {
                    const assignedQuest = gameState.quests[char.currentQuest];
                    const badge = document.createElement('div');
                    badge.className = 'assigned-badge';
                    badge.innerHTML = `üìú Quest: <strong>${assignedQuest.title || assignedQuest.name}</strong>`;
                    parent.appendChild(badge);
                }
            }

            function renderQuests() {
                DOM.questBoard.innerHTML = '';

                if (!gameState.quests || gameState.quests.length === 0) {
                    DOM.questBoard.innerHTML = '<p class="empty-quest-board">No contracts available</p>';
                    return;
                }

                gameState.quests.forEach((quest, index) => {
                    const card = document.createElement('div');
                    card.className = 'quest-scroll';
                    card.dataset.questIndex = index;

                    const title = quest.title || quest.name || 'Unknown Quest';
                    const reward = quest.rewards?.gold || quest.reward || quest.gold || 50;
                    const req = quest.primary_stat || quest.difficulty || 'STR';  // Use primary_stat

                    // Check if assigned and add class
                    if (quest.assignedTo) {
                        card.classList.add('assigned');
                    }

                    card.innerHTML = `
                    <div class="scroll-header">
                        <span class="scroll-title">${title}</span>
                        <span class="scroll-reward">${reward} G</span>
                    </div>
                    <div class="scroll-req">Req: ${req}</div>
                `;

                    // Click to view details
                    card.onclick = () => showQuestDetails(quest);
                    card.style.cursor = 'pointer';

                    // Make quest scrolls draggable
                    if (!quest.assignedTo) {
                        card.draggable = true;

                        card.addEventListener('dragstart', (e) => {
                            draggedQuest = { index, quest };
                            e.dataTransfer.effectAllowed = 'move';
                            e.target.style.opacity = '0.4';
                        });

                        card.addEventListener('dragend', (e) => {
                            e.target.style.opacity = '1';
                            draggedQuest = null;
                        });
                    }

                    DOM.questBoard.appendChild(card);
                });
            }

            function renderReport() {
                // Title
                document.getElementById('report-title').textContent = 'Guild Daily Ledger';
                document.getElementById('report-day').textContent = `Day ${gameState.day}`;

                // Quest Results - Enhanced with colors, injuries, deaths
                DOM.reportContent.innerHTML = '';
                if (gameState.pendingReports && gameState.pendingReports.length > 0) {
                    gameState.pendingReports.forEach(report => {
                        const entry = document.createElement('div');

                        // Color-coded by result
                        let resultClass = 'report-entry';
                        if (report.result === 'SUCCESS') resultClass += ' report-success';
                        else if (report.result === 'MIXED') resultClass += ' report-mixed';
                        else if (report.result === 'FAILURE') resultClass += ' report-failure';

                        entry.className = resultClass;

                        // Build report content
                        let content = `<strong>${report.result}:</strong> ${report.questTitle}<br>`;
                        content += `<em>${report.adventurerName}</em> - ${report.goldEarned || 0} G`;

                        // Show injuries if any
                        if (report.injuries && report.injuries.length > 0) {
                            const injuryNames = report.injuries.map(i => i.name || i).join(', ');
                            content += `<br><span class="injury-warning">‚ö†Ô∏è Injured: ${injuryNames}</span>`;
                        }

                        // Show death
                        if (report.isDead) {
                            content += `<br><span class="death-notice">üíÄ DECEASED</span>`;
                        }

                        // Flavor text
                        if (report.flavorText) {
                            content += `<br><span class="flavor-text">${report.flavorText}</span>`;
                        }

                        entry.innerHTML = content;
                        DOM.reportContent.appendChild(entry);
                    });
                } else {
                    DOM.reportContent.innerHTML = '<p>No guild activity recorded.</p>';
                }

                // Summary
                let totalGold = 0;
                if (gameState.pendingReports) {
                    gameState.pendingReports.forEach(r => totalGold += (r.goldEarned || 0));
                }
                const upkeep = gameState.lastUpkeep ? gameState.lastUpkeep.paid : 0;
                const net = totalGold - upkeep;

                DOM.reportSummary.innerHTML = `
                <div class="summary-line">Gross Revenue: <span class="gold">+${totalGold} G</span></div>
                <div class="summary-line">Daily Upkeep: <span class="red">-${upkeep} G</span></div>
                <div class="summary-line summary-net">Net Profit: <span class="${net >= 0 ? 'gold' : 'red'}">${net >= 0 ? '+' : ''}${net} G</span></div>
            `;
            }

            function renderRoster() {
                DOM.rosterList.innerHTML = '';
                const members = gameState.persistence ? Array.from(gameState.persistence.roster.values()) : [];

                if (members.length === 0) {
                    DOM.rosterList.innerHTML = '<p class="empty-roster">No guild members yet.</p>';
                    return;
                }

                members.forEach(member => {
                    const card = document.createElement('div');
                    card.className = 'roster-card';

                    let status = 'Ready';
                    let statusClass = 'status-ready';
                    if (member.isDead) {
                        status = 'Deceased';
                        statusClass = 'status-dead';
                    } else if (member.injuries && member.injuries.length > 0) {
                        status = 'Injured';
                        statusClass = 'status-injured';
                    } else if (member.isAssigned) {
                        status = 'On Quest';
                        statusClass = 'status-assigned';
                    }

                    card.innerHTML = `
                    <div class="roster-name">${member.name}</div>
                    <div class="roster-class">Lvl ${member.level || 1} ${member.classId}</div>
                    <div class="roster-status ${statusClass}">${status}</div>
                `;

                    DOM.rosterList.appendChild(card);
                });
            }

            // ================================================
            // VISITOR FUNCTIONS
            // ================================================

            function showVisitorModal(visitorData) {
                console.log('Visitor: Showing modal for', visitorData.name);

                const modal = document.getElementById('visitor-modal');
                const title = document.getElementById('visitor-title');
                const dialogue = document.getElementById('visitor-dialogue');
                const choicesContainer = document.getElementById('visitor-choices');

                // Set content
                title.textContent = visitorData.title || visitorData.name;
                dialogue.textContent = visitorData.dialogue;

                // Clear previous choices
                choicesContainer.innerHTML = '';

                // Create choice buttons
                visitorData.choices.forEach((choice, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'btn-large btn-grey';
                    btn.textContent = choice.text;

                    // Check if player can afford
                    if (choice.cost > 0 && gameState.economy.gold < choice.cost) {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        btn.textContent += ' (Not enough gold)';
                    }

                    btn.onclick = () => handleVisitorChoice(visitorData, choice);
                    choicesContainer.appendChild(btn);
                });

                // Show modal
                modal.classList.remove('hidden');
            }

            function handleVisitorChoice(visitorData, choice) {
                console.log('Visitor: Player chose:', choice.text);

                // Apply choice effects
                const success = gameState.visitor.applyChoice(choice, gameState);

                if (!success) {
                    alert("Not enough gold for this choice!");
                    return;
                }

                // Show result text (optional)
                if (choice.resultText) {
                    alert(choice.resultText);
                }

                // Close modal
                document.getElementById('visitor-modal').classList.add('hidden');

                // Update gold display
                updateGoldDisplay();
                updateReputationDisplay();

                // Continue to normal day (load adventurers)
                continueAfterVisitor();
            }

            function continueAfterVisitor() {
                // Continue with the rest of startNewDay() logic
                // Town Pool (weekly reset)
                if (gameState.day === 1 || (gameState.day - 1) % 7 === 0) {
                    gameState.town.generateWeeklyPool(gameState.day);
                }
                gameState.town.generateDailyQueue();
                gameState.currentAdventurer = gameState.town.getNextVisitor();

                // Quests
                if (window.GameData && window.GameData.Quests) {
                    const count = Math.floor(Math.random() * 4) + 3; // 3-6
                    gameState.quests = [...window.GameData.Quests].sort(() => 0.5 - Math.random()).slice(0, count);

                    // Re-inject Crown Mandate if active
                    if (gameState.crown && gameState.crown.activeQuest && gameState.crown.activeQuest.type === 'MANDATE') {
                        const mandate = gameState.crown.activeQuest;
                        if (mandate.status !== 'COMPLETED' && mandate.status !== 'FAILED') {
                            gameState.quests.unshift(mandate);
                        }
                    }
                } else {
                    gameState.quests = [];
                }

                // Render
                renderCharacter();
                renderQuests();
                updateGoldDisplay();
            }

            // ================================================
            // QUEST UI FUNCTIONS
            // ================================================

            function showQuestDetails(quest) {
                console.log('Quest: Showing details for', quest.title);

                const modal = document.getElementById('quest-details-modal');
                const title = document.getElementById('quest-detail-title');
                const desc = document.getElementById('quest-detail-desc');
                const hazard = document.getElementById('quest-detail-hazard');
                const meta = document.getElementById('quest-detail-meta');

                title.textContent = quest.title;
                desc.textContent = quest.desc || quest.description || 'No description available.';

                // Hazard warning
                if (quest.hazard || quest.risk) {
                    hazard.textContent = `‚ö†Ô∏è ${quest.hazard || quest.risk}`;
                } else {
                    hazard.textContent = '';
                }

                // Metadata (type, rank, requirements)
                let metaText = `Type: ${quest.type || 'Unknown'} | Rank: ${quest.rank || '?'} | Req: ${quest.primary_stat || 'STR'}`;
                if (quest.best_class && quest.best_class.length > 0) {
                    metaText += `\nBest for: ${quest.best_class.join(', ')}`;
                }
                meta.textContent = metaText;

                modal.classList.remove('hidden');

                // Click outside modal to close (UX improvement)
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.classList.add('hidden');
                    }
                };
            }

            document.getElementById('btn-close-quest-details')?.addEventListener('click', () => {
                document.getElementById('quest-details-modal').classList.add('hidden');
            });

            // ================================================
            // GAME FLOW FUNCTIONS (from Canvas version)
            // ================================================

            function startGame() {
                gameState.day = 1;
                setScreen('game');
                startNewDay();
            }

            function startNewDay() {
                console.log(`=== DAY ${gameState.day} ===`);

                // Clear previous day's reports
                gameState.pendingReports = [];

                // Crown Check
                if (gameState.crownSystem) {
                    if (!gameState.crown) gameState.crown = { nextVisitDay: 3, activeQuest: null, history: [] };
                    const crownEvent = gameState.crownSystem.checkDaily(gameState);
                    if (crownEvent) {
                        gameState.crownEvent = crownEvent;
                        setScreen('crownEvent');
                        document.getElementById('crown-event-title').textContent = crownEvent.title || 'Royal Messenger';
                        document.getElementById('crown-event-text').textContent = crownEvent.message || 'The Crown has a message for you.';
                        return;
                    }
                }

                // Morning Visitor Check (before adventurers)
                if (gameState.visitor) {
                    const visitor = gameState.visitor.checkForVisitor(gameState.day);
                    if (visitor) {
                        showVisitorModal(visitor);
                        return; // Wait for visitor interaction
                    }
                }

                // Town Pool (weekly reset)
                if (gameState.day === 1 || (gameState.day - 1) % 7 === 0) {
                    gameState.town.generateWeeklyPool(gameState.day);
                }
                gameState.town.generateDailyQueue();
                gameState.currentAdventurer = gameState.town.getNextVisitor();

                // Quests
                if (window.GameData && window.GameData.Quests) {
                    const count = Math.floor(Math.random() * 4) + 3; // 3-6
                    gameState.quests = [...window.GameData.Quests].sort(() => 0.5 - Math.random()).slice(0, count);

                    // Re-inject Crown Mandate if active
                    if (gameState.crown && gameState.crown.activeQuest && gameState.crown.activeQuest.type === 'MANDATE') {
                        const mandate = gameState.crown.activeQuest;
                        if (mandate.status !== 'COMPLETED' && mandate.status !== 'FAILED') {
                            gameState.quests.unshift(mandate);
                        }
                    }
                } else {
                    gameState.quests = [];
                }

                // Render
                renderCharacter();
                renderQuests();
                updateGoldDisplay();
            }

            function endDay() {
                // Collect quest rewards FIRST (before upkeep)
                if (gameState.pendingReports && gameState.pendingReports.length > 0) {
                    let totalGold = 0;
                    gameState.pendingReports.forEach(report => {
                        totalGold += report.goldEarned || 0;
                    });
                    if (totalGold > 0 && gameState.economy) {
                        gameState.economy.addGold(totalGold);
                        console.log(`Collected ${totalGold} gold from quests`);
                    }
                }

                // Process Upkeep
                const upkeep = gameState.economy.processDailyUpkeep();
                gameState.lastUpkeep = upkeep;

                // Roll Event
                if (gameState.events) {
                    gameState.dailyEvent = gameState.events.rollEvent(gameState);
                }

                if (upkeep.bankrupt) {
                    alert("GAME OVER: You ran out of gold!");
                    location.reload();
                    return;
                }

                // Update gold display before showing report
                updateGoldDisplay();

                setScreen('report');
                renderReport();
                gameState.reportOpenedAt = Date.now();
            }

            function nextDay() {
                // Gold already collected in endDay() - removed duplicate

                gameState.day++;

                // CRITICAL FIX: Clear quest assignments for guild members
                if (gameState.persistence) {
                    gameState.persistence.resetDailyState();
                    console.log('‚úÖ Guild member quests cleared for Day', gameState.day);
                }

                setScreen('game');
                startNewDay();
            }

            function hireAdventurer() {
                const hero = gameState.currentAdventurer;
                if (!hero) {
                    console.error("No adventurer to hire!");
                    return;
                }

                if (hero.isGuildMember) {
                    console.log("Already a member");
                    return;
                }

                // Check limit
                const rosterArr = Array.from(gameState.persistence.roster.values());
                const activeCount = rosterArr.filter(m => !m.isDead).length;
                if (activeCount >= 12) {
                    alert(`Guild is full! Active Members: ${activeCount}/12.`);
                    return;
                }

                // Deduct gold
                gameState.economy.gold -= 100;

                // Recruit
                hero.isGuildMember = true;
                gameState.town.recruit(hero.id);

                // Crown quest logic
                if (gameState.crown && gameState.crown.activeQuest && gameState.crown.activeQuest.type === 'TALENT_SCOUT') {
                    if (!gameState.crown.activeQuest.targetRecruitId) {
                        gameState.crown.activeQuest.targetRecruitId = hero.id;
                        gameState.crown.activeQuest.targetRecruitName = hero.name;
                    }
                    hero.isCrownRecruit = true;
                }

                gameState.persistence.addToRoster(hero);
                updateGoldDisplay();

                // Mark as hired (stays visible for quest assignment)
                hero.status = 'HIRED_TODAY';
                renderCharacter(); // Re-render to show "HIRED" badge

                // Note: Adventurer stays on screen for quest assignment
                // Use DISMISS or END DAY buttons to advance to next visitor
            }

            function dismissAdventurer() {
                const current = gameState.currentAdventurer;

                // Clear any quests assigned to this visitor
                if (current && current.isAssigned) {
                    gameState.quests.forEach(quest => {
                        if (quest.assignedTo === current.id) {
                            quest.assignedTo = null;
                            quest.assignedName = null;
                        }
                    });
                }

                // Get next visitor
                gameState.currentAdventurer = gameState.town.getNextVisitor();
                renderCharacter();
                renderQuests();
            }

            // ================================================
            // QUEST ASSIGNMENT (Direct to Current Visitor)
            // ================================================

            function getNextVisitor() {
                if (!gameState.town || gameState.town.dailyQueue.length === 0) {
                    gameState.currentAdventurer = null;
                    renderCharacter();
                    return;
                }
                gameState.currentAdventurer = gameState.town.getNextVisitor();
                renderCharacter();
            }

            function assignQuestToVisitor(quest, questIndex) {
                const visitor = gameState.currentAdventurer;
                if (!visitor) {
                    console.error("No visitor at desk!");
                    return;
                }

                // Validation: Check if visitor already has a quest
                if (visitor.isAssigned && visitor.currentQuest !== null) {
                    console.warn(`${visitor.name} already has a quest assigned!`);
                    return;
                }

                // Validation: Check if quest is already assigned
                if (quest.assignedTo) {
                    console.warn(`Quest "${quest.title}" is already assigned!`);
                    return;
                }

                console.log(`‚úÖ Assigning "${quest.title}" to ${visitor.name}`);

                // Mark as assigned
                visitor.isAssigned = true;
                visitor.currentQuest = questIndex;

                // Process with Resolution System
                if (window.GameSystems && window.GameSystems.ResolutionManager) {
                    visitor.economyRef = gameState.economy;
                    const result = window.GameSystems.ResolutionManager.resolve(quest, visitor);

                    // CRITICAL FIX: Only save to roster if this IS a guild member
                    // Town pool visitors should NOT become guild members just from taking quests!
                    if (visitor.isGuildMember && gameState.persistence) {
                        gameState.persistence.saveAdventurer(visitor, {
                            result: result.result,
                            questTitle: quest.title
                        });
                    }

                    // Store result for end-of-day report
                    if (!gameState.pendingReports) gameState.pendingReports = [];
                    gameState.pendingReports.push(result);
                    console.log(`Quest resolved: ${result.result}`);
                }

                // Remove quest from board
                gameState.quests.splice(questIndex, 1);

                // Re-render quests
                renderQuests();

                // AUTO-PROGRESS: Show next visitor after brief delay
                setTimeout(() => {
                    getNextVisitor();
                }, 300);
            }

            // ================================================
            // ROSTER RENDERING
            // ================================================

            function renderRoster() {
                const list = DOM.rosterList;
                list.innerHTML = '';

                if (!gameState.persistence || !gameState.persistence.roster) {
                    list.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No guild members yet</p>';
                    return;
                }

                const members = Array.from(gameState.persistence.roster.values());

                if (members.length === 0) {
                    list.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No guild members yet</p>';
                    return;
                }

                members.forEach(member => {
                    const row = document.createElement('div');
                    row.className = 'roster-row';
                    row.onclick = () => showCharacterDetails(member);

                    const status = getMemberStatus(member);
                    const statusIcon = getStatusIcon(member);

                    row.innerHTML = `
                        <img src="${member.portraitPath || 'assets/portraits/human_warrior_male_1.png'}" 
                             class="roster-portrait" 
                             onerror="this.src='assets/portraits/human_warrior_male_1.png'" />
                        <div class="roster-info">
                            <div class="roster-name">${member.name}</div>
                            <div class="roster-details">
                                Lvl ${member.level || 1} ‚Ä¢ ${member.classId} ‚Ä¢ ${statusIcon} ${status}
                            </div>
                        </div>
                        <div class="roster-stats-preview">
                            STR ${member.stats.str} ‚Ä¢ INT ${member.stats.int} ‚Ä¢ DEX ${member.stats.dex}
                        </div>
                    `;

                    list.appendChild(row);
                });
            }

            function getMemberStatus(member) {
                if (member.isDead) return 'Dead';
                if (member.injuries && member.injuries.length > 0) return 'Injured';
                if (member.isAssigned || member.assignedQuest) return 'On Quest';
                return 'Ready';
            }

            function getStatusIcon(member) {
                if (member.isDead) return 'üíÄ';
                if (member.injuries && member.injuries.length > 0) return 'üè•';
                if (member.isAssigned || member.assignedQuest) return '‚öîÔ∏è';
                return '‚úÖ';
            }

            function showCharacterDetails(member) {
                // Use existing inspector modal for now, will upgrade later
                const modal = document.getElementById('inspector-modal');
                const content = document.getElementById('inspector-content');

                const status = getMemberStatus(member);
                const qh = member.questHistory || { total: 0, byRank: {} };

                let detailText = `=== ${member.name} ===\n\n`;
                detailText += `Level: ${member.level || 1}\n`;
                detailText += `Class: ${member.classId}\n`;
                detailText += `Race: ${member.race}\n`;
                detailText += `Status: ${status}\n`;
                detailText += `\n--- STATS ---\n`;
                detailText += `STR: ${member.stats.str}\n`;
                detailText += `INT: ${member.stats.int}\n`;
                detailText += `DEX: ${member.stats.dex}\n`;
                detailText += `VIT: ${member.stats.vit}\n`;

                if (member.xp !== undefined) {
                    detailText += `\nXP: ${member.xp || 0} / ${member.xpToNext || 100}\n`;
                }

                if (member.traits && member.traits.length > 0) {
                    detailText += `\n--- TRAITS ---\n`;
                    member.traits.forEach(t => detailText += `‚Ä¢ ${t}\n`);
                }

                if (member.injuries && member.injuries.length > 0) {
                    detailText += `\n--- INJURIES ---\n`;
                    member.injuries.forEach(inj => {
                        const duration = inj.duration === -1 ? 'Permanent' : `${inj.duration} days`;
                        detailText += `‚Ä¢ ${inj.name} (${duration})\n`;
                    });
                }

                detailText += `\n--- SERVICE RECORD ---\n`;
                detailText += `Total Missions: ${qh.total || 0}\n`;
                if (qh.byRank) {
                    detailText += `S-Rank: ${qh.byRank.S || 0} ‚Ä¢ A-Rank: ${qh.byRank.A || 0}\n`;
                    detailText += `B-Rank: ${qh.byRank.B || 0} ‚Ä¢ C-Rank: ${qh.byRank.C || 0}\n`;
                }

                if (member.visuals && member.visuals.length > 0) {
                    detailText += `\n--- PHYSIQUE ---\n`;
                    detailText += member.visuals.join(', ');
                }

                content.textContent = detailText;
                modal.classList.remove('hidden');
            }

            // ================================================
            // EVENT LISTENERS
            // ================================================

            document.getElementById('btn-start').addEventListener('click', startGame);
            document.getElementById('btn-hire').addEventListener('click', hireAdventurer);
            document.getElementById('btn-dismiss').addEventListener('click', dismissAdventurer);
            document.getElementById('btn-end-day').addEventListener('click', endDay);
            document.getElementById('btn-next-day').addEventListener('click', nextDay);
            document.getElementById('btn-roster-toggle').addEventListener('click', () => {
                setScreen('roster');
                renderRoster();
            });
            document.getElementById('btn-close-roster').addEventListener('click', () => {
                setScreen('game');
            });
            document.getElementById('btn-acknowledge-crown').addEventListener('click', () => {
                setScreen('game');
                startNewDay(); // Resume
            });

            // ================================================
            // ADVENTURER DATA (Inline - ES6 module not loading)
            // ================================================

            window.ADVENTURER_DATA = {
                archetypes: {
                    MARTIAL: {
                        name: "Martial",
                        classes: [
                            { id: "knight", name: "Knight-Errant", traits: ["Honorbound", "Arrogant"], stats: { str: [8, 10], int: [2, 5], dex: [4, 6] } },
                            { id: "barbarian", name: "Barbarian", traits: ["Battle-Rage", "Illiterate"], stats: { str: [9, 10], int: [1, 3], dex: [5, 7] } },
                            { id: "mercenary", name: "Mercenary", traits: ["Greedy", "Pragmatic"], stats: { str: [6, 8], int: [4, 6], dex: [5, 7] } },
                            { id: "guard", name: "Town Guard", traits: ["Lazy", "Corrupt"], stats: { str: [5, 7], int: [3, 5], dex: [4, 6] } }
                        ]
                    },
                    ARCANE: {
                        name: "Arcane",
                        classes: [
                            { id: "battle_mage", name: "Battle Mage", traits: ["Pyromaniac", "Short-Tempered"], stats: { str: [4, 6], int: [8, 10], dex: [4, 6] } },
                            { id: "scholar", name: "Scholar", traits: ["Cowardly", "Curious"], stats: { str: [2, 4], int: [9, 10], dex: [3, 5] } },
                            { id: "necromancer", name: "Necromancer", traits: ["Outcast", "Creepy"], stats: { str: [3, 5], int: [8, 10], dex: [3, 5] } }
                        ]
                    },
                    CUNNING: {
                        name: "Cunning",
                        classes: [
                            { id: "rogue", name: "Rogue", traits: ["Greedy", "Traitor"], stats: { str: [3, 5], int: [5, 7], dex: [8, 10] } },
                            { id: "ranger", name: "Ranger", traits: ["Loner", "Nature-Lover"], stats: { str: [5, 7], int: [4, 6], dex: [8, 10] } },
                            { id: "assassin", name: "Assassin", traits: ["Cold-Blooded", "Contract_Killer"], stats: { str: [5, 7], int: [6, 8], dex: [9, 10] } }
                        ]
                    },
                    DIVINE: {
                        name: "Divine",
                        classes: [
                            { id: "cleric", name: "Cleric", traits: ["Zealot", "Pacifist"], stats: { str: [5, 7], int: [7, 9], dex: [3, 5] } },
                            { id: "paladin", name: "Paladin", traits: ["Lawful Stupid", "Judgemental"], stats: { str: [8, 10], int: [4, 6], dex: [4, 6] } },
                            { id: "monk", name: "Monk", traits: ["Vow of Silence", "Disciplined"], stats: { str: [7, 9], int: [6, 8], dex: [9, 10] } }
                        ]
                    }
                }
            };

            // ================================================
            // ADVENTURER GENERATOR (Inline for compatibility)
            // ================================================

            class AdventurerGenerator {
                static generate(day = 1) {
                    if (!window.ADVENTURER_DATA) {
                        console.error("ADVENTURER_DATA not loaded!");
                        return null;
                    }

                    const archetypeKeys = Object.keys(ADVENTURER_DATA.archetypes);
                    const archetypeKey = archetypeKeys[Math.floor(Math.random() * archetypeKeys.length)];
                    const archetypeData = ADVENTURER_DATA.archetypes[archetypeKey];
                    const charClass = archetypeData.classes[Math.floor(Math.random() * archetypeData.classes.length)];

                    const stats = {
                        str: this.randomRange(charClass.stats.str[0], charClass.stats.str[1]),
                        int: this.randomRange(charClass.stats.int[0], charClass.stats.int[1]),
                        dex: this.randomRange(charClass.stats.dex[0], charClass.stats.dex[1]),
                        vit: this.randomRange(3, 8)
                    };

                    const traits = [...charClass.traits];
                    const race = this.pickRaceForClass(charClass.id);
                    const equipment = { mainHand: "Basic Weapon", armor: "Basic Armor" };

                    const names = ["Garrett", "Lyra", "Thorn", "Elara", "Ragnar", "Sylas", "Kael", "Mira"];
                    const name = names[Math.floor(Math.random() * names.length)] + " the " + charClass.name;

                    // Use Adventurer constructor from models/Adventurer.js
                    return new window.GameSystems.Adventurer({
                        name: name,
                        archetype: archetypeKey,
                        classId: charClass.id,
                        race: race,
                        stats: stats,
                        traits: traits,
                        equipment: equipment
                    });
                }

                static pickRaceForClass(classId) {
                    const raceMap = {
                        warrior: 'human', knight: 'human', barbarian: 'orc',
                        guard: 'human', pit_fighter: 'human', ronin: 'human', mercenary: 'human',
                        battle_mage: 'elf', scholar: 'elf', necromancer: 'human',
                        illusionist: 'elf', elementalist: 'elf', hedge_wizard: 'elf',
                        rogue: 'human', ranger: 'elf', bard: 'human',
                        assassin: 'human', treasure_hunter: 'human', spy: 'human',
                        cleric: 'human', paladin: 'dwarf', druid: 'elf',
                        monk: 'human', cultist: 'human'
                    };
                    return raceMap[classId] || 'human';
                }

                static randomRange(min, max) {
                    return Math.floor(Math.random() * (max - min + 1)) + min;
                }
            }

            // Register globally for Town system
            window.GameSystems = window.GameSystems || {};
            window.GameSystems.AdventurerGenerator = AdventurerGenerator;

            // ================================================
            // INIT
            // ================================================

            async function init() {
                console.log('üéÆ Initializing Guild Master Mobile...');

                // Initialize Systems
                gameState.economy = new window.GameSystems.EconomyManager(100); // Start with 100 gold
                gameState.inspector = new window.GameSystems.Inspector();
                gameState.persistence = new window.GameSystems.PersistenceManager();
                gameState.events = new window.GameSystems.EventManager();
                gameState.town = new window.GameSystems.TownManager();
                gameState.crownSystem = new window.GameSystems.CrownSystem();
                gameState.visitor = new window.GameSystems.VisitorSystem();

                console.log('‚úÖ All systems initialized');
                console.log('üìä AdventurerGenerator registered:', !!window.GameSystems.AdventurerGenerator);
                console.log('üìä Quest Data loaded:', window.GameData?.Quests?.length || 0, 'quests');
                console.log('üéÆ Game ready! Click START to begin.');
            }

            init();
        </script>

</body>

</html>